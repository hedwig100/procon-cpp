{
    "./string/trie.cpp": {
        "prefix": "snp trie",
        "body": [
            "",
            "template <int char_size, int base>",
            "struct Trie {",
            "    struct Node {",
            "        vector<int> child, accept;",
            "        int c, common;",
            "        Node(int c) : c(c), common(0) {",
            "            child.assign(char_size, -1);",
            "        }",
            "    };",
            "    vector<Node> tree;",
            "    int root;",
            "    Trie() : root(0) {",
            "        tree.push_back(Node(root));",
            "    }",
            "    void insert(const string &s, int id) {",
            "        int node_id = 0;",
            "        for (int i = 0; i < (int)s.size(); ++i) {",
            "            int c        = (int)(s[i] - base);",
            "            int &next_id = tree[node_id].child[c];",
            "            if (next_id < 0) {",
            "                next_id = (int)tree.size();",
            "                tree.push_back(Node(c));",
            "            }",
            "            ++tree[node_id].common;",
            "            node_id = next_id;",
            "        }",
            "        ++tree[node_id].common;",
            "        tree[node_id].accept.push_back(id);",
            "    }",
            "    // insert s to Trie",
            "    void insert(const string &s) {",
            "        insert(s, tree[0].common);",
            "    }",
            "    // return the number of s in Trie",
            "    int search(const string &s, bool prefix = false) {",
            "        int node_id = 0;",
            "        for (int i = 0; i < (int)s.size(); ++i) {",
            "            int c        = (int)(s[i] - base);",
            "            int &next_id = tree[node_id].child[c];",
            "            if (next_id < 0) return 0;",
            "            node_id = next_id;",
            "        }",
            "        return prefix ? 1 : (int)tree[node_id].accept.size();",
            "    }",
            "    // if prefix of s in Trie",
            "    bool prefix(const string &s) {",
            "        return search(s, true) > 0;",
            "    }",
            "};",
            "",
            "// Trie<26,'a'> tr"
        ],
        "description": ""
    },
    "./string/suffix_array.cpp": {
        "prefix": "snp suffix_array",
        "body": [
            "",
            "vector<int> suffix_array(string &s) {",
            "    // O(Nlog^2N)",
            "    int n = s.size();",
            "    vector<int> sa(n + 1), rank(n + 1), tmp(n + 1);",
            "    for (int i = 0; i <= n; ++i) {",
            "        sa[i]   = i;",
            "        rank[i] = (i < n ? s[i] : -1);",
            "    }",
            "    for (int k = 1; k <= n; k <<= 1) {",
            "        auto cmp = [&](int i, int j) {",
            "            if (rank[i] != rank[j])",
            "                return rank[i] < rank[j];",
            "            else {",
            "                int ri = (i + k <= n ? rank[i + k] : -1);",
            "                int rj = (j + k <= n ? rank[j + k] : -1);",
            "                return ri < rj;",
            "            }",
            "        };",
            "        sort(sa.begin(), sa.end(), cmp);",
            "        tmp[sa[0]] = 0;",
            "        for (int i = 1; i <= n; ++i) {",
            "            tmp[sa[i]] = tmp[sa[i - 1]] + (cmp(sa[i - 1], sa[i]) ? 1 : 0);",
            "        }",
            "        for (int i = 0; i <= n; ++i) {",
            "            rank[i] = tmp[i];",
            "        }",
            "    }",
            "    return sa;",
            "}",
            "",
            "vector<int> lcp_array(string &s, vector<int> &sa) {",
            "    int n = s.size();",
            "    vector<int> rank(n);",
            "    for (int i = 0; i < n; ++i) {",
            "        rank[sa[i]] = i;",
            "    }",
            "}"
        ],
        "description": ""
    },
    "./string/run_length.cpp": {
        "prefix": "snp run_length",
        "body": [
            "",
            "vector<pair<char, int>> run_length(string s) {",
            "    vector<pair<char, int>> ret;",
            "    pair<char, int> now = make_pair(s[0], 1);",
            "    for (int i = 1; i < (int)s.size(); i++) {",
            "        if (s[i] == s[i - 1]) {",
            "            now.second++;",
            "        } else {",
            "            ret.push_back(now);",
            "            now = make_pair(s[i], 1);",
            "        }",
            "    }",
            "    ret.push_back(now);",
            "    return ret;",
            "}"
        ],
        "description": ""
    },
    "./string/rolling_hash.cpp": {
        "prefix": "snp rolling_hash",
        "body": [
            "",
            "using u64                 = unsigned long long;",
            "constexpr u64 M           = 2305843009213693951; // 2^61 - 1",
            "constexpr u64 MASK31      = 2147483647;          // 2^31 - 1",
            "constexpr u64 MASK30      = 1073741823;          // 2^30 - 1",
            "constexpr u64 POSITIVIZER = 4 * M;",
            "",
            "u64 CalcMod(u64 x) {",
            "    u64 res = (x >> 61) + (x & M);",
            "    if (res >= M) res -= M;",
            "    return res;",
            "}",
            "u64 mul(u64 x, u64 y) {",
            "    u64 au = (x >> 31), ad = (x & MASK31), bu = (y >> 31), bd = (y & MASK31);",
            "    u64 m  = au * bd + ad * bu;",
            "    u64 mu = (m >> 30), md = (m & MASK30);",
            "    u64 ans = ((au * bu) << 1) + mu + (md << 31) + ad * bd;",
            "    return CalcMod(ans);",
            "}",
            "",
            "struct RollingHash {",
            "    static u64 B;",
            "    int N;",
            "    vector<u64> hash, power;",
            "    RollingHash(const string &s) {",
            "        N = (int)s.size();",
            "        hash.resize(N + 1, 0);",
            "        power.resize(N + 1, 0);",
            "        hash[0]  = 0;",
            "        power[0] = 1;",
            "        for (int i = 0; i < (int)s.size(); ++i) {",
            "            hash[i + 1]  = CalcMod(mul(hash[i], B) + s[i]);",
            "            power[i + 1] = mul(power[i], B);",
            "        }",
            "    }",
            "    u64 get() { return hash[N]; }",
            "    u64 get(int k) { return hash[k]; }",
            "    u64 get(int l, int r) { return CalcMod(hash[r] + POSITIVIZER - mul(hash[l], power[r - l])); }",
            "};",
            "",
            "mt19937_64 mt;",
            "uniform_int_distribution<unsigned long long> rng(2, M - 2);",
            "unsigned long long RollingHash::B = rng(mt);",
            "",
            "/*",
            "",
            "// two 32bit MOD version",
            "struct RollingHash {",
            "    using u64 = unsigned long long;",
            "    static const u64 M1 = 2147483647,M2 = 1000000007;",
            "    static u64 B1,B2;",
            "    int N;",
            "    vector<u64> hash1,hash2,power1,power2;",
            "",
            "    RollingHash(string &s) {",
            "        N = s.size();",
            "        power1.resize(N + 1); power2.resize(N + 1); hash1.resize(N + 1); hash2.resize(N + 1);",
            "        power1[0] = 1;        power2[0] = 1;        hash1[0] = 0;        hash2[0] = 0;",
            "        for (int i = 0;i < N; ++i) {",
            "            power1[i + 1] = power1[i] * B1 % M1;",
            "            power2[i + 1] = power2[i] * B2 % M2;",
            "            hash1[i + 1] = (hash1[i] * B1 + s[i]) % M1;",
            "            hash2[i + 1] = (hash2[i] * B2 + s[i]) % M2;",
            "        }",
            "    }",
            "    // return hash of S",
            "    pair<u64,u64> get() {",
            "        return make_pair(hash1[N],hash2[N]);",
            "    }",
            "    // return hash of S[0,k)",
            "    pair<u64,u64> get(int k) {",
            "        return make_pair(hash1[k],hash2[k]);",
            "    }",
            "    // return hash of S[l,r)",
            "    pair<u64,u64> get(int l,int r) {",
            "        u64 x = (hash1[r] - (hash1[l] * power1[r - l]) % M1 + M1) % M1;",
            "        u64 y = (hash2[r] - (hash2[l] * power2[r - l]) % M2 + M2) % M2;",
            "        return make_pair(x,y);",
            "    }",
            "    //return if S[l1,r1) == S[l2,r2)",
            "    bool equal(int l1,int r1,int l2,int r2) {",
            "        return get(l1,r1) == get(l2,r2);",
            "    }",
            "};",
            "",
            "mt19937_64 mt;",
            "uniform_int_distribution<unsigned long long> rand1(2,RollingHash::M1 - 2);",
            "uniform_int_distribution<unsigned long long> rand2(2,RollingHash::M2 - 2);",
            "unsigned long long RollingHash::B1 = rand1(mt);",
            "unsigned long long RollingHash::B2 = rand2(mt);",
            "",
            "using u64 = unsigned long long;",
            "using Pu = pair<u64,u64>;",
            "",
            "*/"
        ],
        "description": ""
    },
    "./string/mp.cpp": {
        "prefix": "snp mp",
        "body": [
            "",
            "// MP",
            "// l=(\u6587\u5b57\u5217S\u306e\u9577\u3055)\u3068\u3057\u3066i=1,...,l+1\u306b\u3064\u3044\u3066",
            "// A[i] = (S[0:i)\u306e\u63a5\u5c3e\u8f9e\u3068\u63a5\u982d\u8f9e\u3067\u3042\u3063\u3066\u4e00\u81f4\u3059\u308b\u3088\u3046\u306a\u3082\u306e\u306e\u6700\u5927\u306e\u9577\u3055, \u305f\u3060\u3057S[0:i)\u5168\u4f53\u306f\u81ea\u660e\u306b\u4e00\u81f4\u3059\u308b\u306e\u3067\u9664\u304f)",
            "// \u306a\u308b\u914d\u5217\u3092\u8fd4\u3059\u3002A[0]\u306f\u5e38\u306b-1",
            "// complexity: O(|S|)",
            "vector<int> MP(string s) {",
            "    int l = (int)s.size();",
            "    vector<int> A(l + 1, -1);",
            "    int j = -1;",
            "    for (int i = 0; i < l; i++) {",
            "        while (j >= 0 && s[i] != s[j])",
            "            j = A[j];",
            "        j++;",
            "        A[i + 1] = j;",
            "    }",
            "    return A;",
            "}"
        ],
        "description": ""
    },
    "./string/z_algorithm.cpp": {
        "prefix": "snp z_algorithm",
        "body": [
            "",
            "// Z-algorithum",
            "// l=(\u6587\u5b57\u5217S\u306e\u9577\u3055)\u3068\u3057\u3066i=0,..,l-1\u306b\u5bfe\u3057\u3066",
            "// Z[i] = (S\u3068S[i:l)\u306e\u6700\u9577\u5171\u901a\u63a5\u982d\u8f9e\u306e\u9577\u3055)",
            "// \u306a\u308b\u914d\u5217A\u3092\u8fd4\u3059\u3002",
            "// complexity : O(|S|)",
            "vector<int> Z_algorithm(string s) {",
            "    int l = (int)s.size();",
            "    vector<int> Z(l);",
            "    Z[0]  = l;",
            "    int i = 1, j = 0;",
            "    while (i < l) {",
            "        while (i + j < l && s[j] == s[i + j])",
            "            j++;",
            "        Z[i] = j;",
            "",
            "        if (j == 0) {",
            "            i++;",
            "            continue;",
            "        }",
            "        int k = 1;",
            "        while (k < j && k + Z[k] < j) {",
            "            Z[i + k] = Z[k];",
            "            k++;",
            "        }",
            "        i += k;",
            "        j -= k;",
            "    }",
            "",
            "    return Z;",
            "}"
        ],
        "description": ""
    },
    "./data_structures/wavelet_matrix.cpp": {
        "prefix": "snp wavelet_matrix",
        "body": [
            "",
            "struct FullyIndexableDictionary {",
            "    int bit_size, block_size;",
            "    vector<unsigned int> bit;",
            "    vector<int> block;",
            "",
            "    FullyIndexableDictionary(int bit_size = 0) : bit_size(bit_size), block_size((bit_size + 32 - 1) >> 5) {",
            "        bit.resize(bit_size, 0);",
            "        block.resize(block_size, 0);",
            "    }",
            "",
            "    // set(k) set the k-th bit",
            "    // constraint: 0 <= k < bit_size",
            "    // time complexity: O(1)",
            "    void set(int k) {",
            "        bit[k >> 5] |= 1U << (k & 31);",
            "    }",
            "",
            "    void build() {",
            "        block[0] = 0;",
            "        for (int i = 1; i < block_size; ++i) {",
            "            block[i] = block[i - 1] + __builtin_popcount(bit[i - 1]);",
            "        }",
            "    }",
            "",
            "    // op[k] returns k-th bit",
            "    // constraint: 0 <= k < bit_size",
            "    // time complexity: O(1)",
            "    bool operator[](int k) {",
            "        return bool((bit[k >> 5] >> (k & 31)) & 1U);",
            "    }",
            "",
            "    // _rank(k) returns the number of 1 in [0,k)",
            "    // constraint: 0 <= k <= bit_size",
            "    // time complexity: O(1)",
            "    int _rank(int k) {",
            "        return block[k >> 5] + __builtin_popcount(bit[k >> 5] & ((1U << (k & 31)) - 1));",
            "    }",
            "",
            "    // rank(v,k) returns the number of v in [0,k)",
            "    // constraint: 0 <= k <= bit_size,(v = 0 or v = 1)",
            "    // time complexity: O(1)",
            "    int rank(bool v, int k) {",
            "        return (v ? _rank(k) : k - _rank(k));",
            "    }",
            "",
            "    // select(v,k) returns the k-th position of v",
            "    // constraint: k >= 0, (v = 0 or v = 1)",
            "    // time complexity: O(logN),N = bit_size",
            "    int select(bool v, int k) {",
            "        if (k < 0 || rank(v, bit_size) <= k) return -1;",
            "        int l = 0, r = bit_size;",
            "        while (r - l > 1) {",
            "            int mid = (r + l) >> 1;",
            "            if (rank(v, mid) >= k + 1)",
            "                r = mid;",
            "            else",
            "                l = mid;",
            "        }",
            "        return r - 1;",
            "    }",
            "",
            "    int select(bool v, int i, int l) {",
            "        return select(v, i + rank(v, l));",
            "    }",
            "};",
            "",
            "template <class T, int MAXLOG>",
            "struct WaveletMatrix {",
            "    int len;",
            "    FullyIndexableDictionary mat[MAXLOG];",
            "    int zeros[MAXLOG], buff1[MAXLOG], buff2[MAXLOG];",
            "",
            "    WaveletMatrix(vector<T> data) {",
            "        len = data.size();",
            "        vector<T> l(len), r(len);",
            "        for (int dep = 0; dep < MAXLOG; ++dep) {",
            "            mat[dep] = FullyIndexableDictionary(len + 1);",
            "            int p = 0, q = 0;",
            "            for (int i = 0; i < len; ++i) {",
            "                bool k = (data[i] >> (MAXLOG - (dep + 1))) & 1;",
            "                if (k)",
            "                    r[q++] = data[i], mat[dep].set(i);",
            "                else",
            "                    l[p++] = data[i];",
            "            }",
            "            zeros[dep] = p;",
            "            mat[dep].build();",
            "            swap(l, data);",
            "            for (int i = 0; i < q; ++i)",
            "                data[p + i] = r[i];",
            "        }",
            "    }",
            "    T access(int k) {",
            "        T res    = 0;",
            "        bool bit = 0;",
            "        for (int dep = 0; dep < MAXLOG; ++dep) {",
            "            bit = mat[dep][k];",
            "            res = (res << 1) | bit;",
            "            k   = mat[dep].rank(bit, k) + zeros[dep] * bit;",
            "        }",
            "        return res;",
            "    }",
            "    // return the number of v in [0,k)",
            "    int rank(T v, int k) {",
            "        int l = 0, r = k;",
            "        for (int dep = 0; dep < MAXLOG; ++dep) {",
            "            buff1[dep] = l, buff2[dep] = r;",
            "            bool bit = (v >> (MAXLOG - (dep + 1))) & 1;",
            "            l        = mat[dep].rank(bit, l) + zeros[dep] * bit;",
            "            r        = mat[dep].rank(bit, r) + zeros[dep] * bit;",
            "        }",
            "        return r - l;",
            "    }",
            "    // return the position of k-th v",
            "    int select(T v, int k) {",
            "        rank(v, len);",
            "        for (int dep = MAXLOG - 1; dep >= 0; --dep) {",
            "            bool bit = (v >> (MAXLOG - (dep + 1))) & 1;",
            "            k        = mat[dep].select(bit, k, buff1[dep]);",
            "            if (k >= buff2[dep] || k < 0) return -1;",
            "            k -= buff1[dep];",
            "        }",
            "        return k;",
            "    }",
            "    // return k-th largest value in [l,r)",
            "    T quantile(int l, int r, int k) {",
            "        if (r - l <= k || k < 0) return -1;",
            "        T res = 0;",
            "        for (int dep = 0; dep < MAXLOG; ++dep) {",
            "            int p = mat[dep].rank(1, l);",
            "            int q = mat[dep].rank(1, r);",
            "            if (q - p < k) {",
            "                l = p + zeros[dep];",
            "                r = q + zeros[dep];",
            "                res |= (T(1) << (MAXLOG - (dep + 1)));",
            "            } else {",
            "                k -= (q - p);",
            "                l -= p;",
            "                r -= q;",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./data_structures/binary_indexed_tree2d.cpp": {
        "prefix": "snp binary_indexed_tree2d",
        "body": [
            "",
            "// BinaryIndexedTree2D",
            "template <typename T>",
            "struct BinaryIndexedTree2D {",
            "    int h, w;",
            "    vector<vector<T>> data;",
            "",
            "    BinaryIndexedTree2D(int h, int w) : h(h), w(w) {",
            "        data.assign(h + 1, std::vector<T>(w + 1, 0));",
            "    }",
            "",
            "    // add",
            "    // A[k][l] += x\u3068\u3059\u308b.",
            "    // \u5236\u7d04: 0 <= k < h,0 <= l < w",
            "    // \u8a08\u7b97\u91cf: O(loghlogw)",
            "    void add(int k, int l, T x) {",
            "        k++, l++;",
            "        for (int i = k; i <= h; i += (i & -i)) {",
            "            for (int j = l; j <= w; j += (j & -j)) {",
            "                data[i][j] += x;",
            "            }",
            "        }",
            "    }",
            "",
            "    // _sum",
            "    // \u03a3_{0 <= i <= k,0 <= j <= l} A[i][j]\u3092\u6c42\u3081\u308b.",
            "    // \u5236\u7d04: 0 <= k < h,0 <= l < w",
            "    // \u8a08\u7b97\u91cf: O(loghlogw)",
            "    T _sum(int k, int l) {",
            "        if (k < 0 || l < 0) return 0;",
            "        k = min(k, h - 1);",
            "        l = min(l, w - 1);",
            "",
            "        T ret = 0;",
            "        k++, l++;",
            "        for (int i = k; i > 0; i -= (i & -i)) {",
            "            for (int j = l; j > 0; j -= (j & -j)) {",
            "                ret += data[i][j];",
            "            }",
            "        }",
            "        return ret;",
            "    }",
            "",
            "    // sum",
            "    // \u03a3_{h1 <= i < h2 and w1 <= j < w2}A[i][j]\u3092\u6c42\u3081\u308b.",
            "    // \u5236\u7d04: 0 <= h1 <= h2 <= h,0 <= w1 <= w2 <= w",
            "    // \u8a08\u7b97\u91cf: O(loghlogw)",
            "    T sum(int h1, int h2, int w1, int w2) {",
            "        return _sum(h2 - 1, w2 - 1) - _sum(h2 - 1, w1 - 1) - _sum(h1 - 1, w2 - 1) + _sum(h1 - 1, w1 - 1);",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./data_structures/sliding_window_aggregation.cpp": {
        "prefix": "snp sliding_window_aggregation",
        "body": [
            "",
            "// SlidingWindowAggregation",
            "// \u534a\u7fa4\u306b\u5bfe\u3057\u3066\u4ee5\u4e0b\u306e\u3053\u3068\u304c\u884c\u3048\u308b\u30c7\u30fc\u30bf\u69cb\u9020",
            "//",
            "// push(x): x\u3092\u8ffd\u52a0\u3059\u308b",
            "// pop(): queue\u306e\u8981\u9818\u3067\u8981\u7d20\u3092\u53d6\u308a\u9664\u304f(FIFO)",
            "// fold(): \u4eca\u5165\u3063\u3066\u3044\u308b\u8981\u7d20\u3092\u65e9\u304f\u5165\u3063\u3066\u3044\u305f\u65b9\u304b\u3089a0,a1,...,an\u3068\u3057\u305f\u3068\u304d\u306ba0*a1*...an\u3092\u8a08\u7b97\u3059\u308b.",
            "template <typename SemiGrp>",
            "struct SlidingWindowAggregation {",
            "    using Fx = function<SemiGrp(const SemiGrp &, const SemiGrp &)>;",
            "",
            "    vector<SemiGrp> left, left_cum, right, right_cum;",
            "    Fx op;",
            "",
            "    SlidingWindowAggregation(Fx op) : op(op) {}",
            "",
            "    inline int size() { return (int)left.size() + (int)right.size(); }",
            "    inline bool empty() { return size() == 0; }",
            "",
            "    // push",
            "    // x\u3092\u8ffd\u52a0\u3059\u308b",
            "    // \u8a08\u7b97\u91cf: O(1)",
            "    void push(SemiGrp x) {",
            "        if ((int)right.size() == 0)",
            "            right.push_back(x), right_cum.push_back(x);",
            "        else",
            "            right.push_back(x), right_cum.push_back(op(right_cum.back(), x));",
            "    }",
            "",
            "    // pop",
            "    // \u30c7\u30fc\u30bf\u3092FIFO\u3067\u53d6\u308a\u51fa\u3059. \u7a7a\u306e\u5834\u5408\u306f\u4f55\u3082\u3057\u306a\u3044.",
            "    // \u8a08\u7b97\u91cf: \u511f\u5374 O(1)",
            "    void pop() {",
            "        if (empty()) return;",
            "        if ((int)left.size() != 0) {",
            "            left.pop_back(), left_cum.pop_back();",
            "            return;",
            "        }",
            "",
            "        int sz = (int)right.size();",
            "        if (sz == 1) {",
            "            right.pop_back(), right_cum.pop_back();",
            "            return;",
            "        }",
            "        left.push_back(right.back()), left_cum.push_back(right.back());",
            "        right.pop_back(), right_cum.pop_back();",
            "        for (int i = 1; i < sz - 1; i++) {",
            "            left.push_back(right.back()), left_cum.push_back(op(right.back(), left_cum.back()));",
            "            right.pop_back(), right_cum.pop_back();",
            "        }",
            "        right.pop_back(), right_cum.pop_back();",
            "    }",
            "",
            "    // fold",
            "    // \u4eca\u5165\u3063\u3066\u3044\u308b\u8981\u7d20\u3092\u65e9\u304f\u5165\u3063\u3066\u3044\u305f\u65b9\u304b\u3089a0,a1,...,an\u3068\u3057\u305f\u3068\u304d\u306ba0*a1*...an\u3092\u8fd4\u3059.",
            "    // \u5236\u7d04: \u7a7a\u3067\u306f\u306a\u3044",
            "    // \u8a08\u7b97\u91cf: O(1)",
            "    SemiGrp fold() {",
            "        assert(!empty());",
            "        if ((int)left.size() == 0)",
            "            return right_cum.back();",
            "        else if ((int)right.size() == 0)",
            "            return left_cum.back();",
            "        else",
            "            return op(left_cum.back(), right_cum.back());",
            "    }",
            "",
            "    friend ostream &operator<<(ostream &os, const SlidingWindowAggregation<SemiGrp> &swag) {",
            "        for (int i = (int)swag.left.size() - 1; i >= 0; i--)",
            "            os << swag.left[i] << ' ';",
            "        for (int i = 0; i < (int)swag.right.size(); i++)",
            "            os << swag.right[i] << ' ';",
            "        return os;",
            "    }",
            "};",
            "",
            "// example:",
            "// using SemiGrp = pair<int, int>;",
            "// SlidingWindowAggregation<SemiGrp> swag([](const SemiGrp &a, const SemiGrp &b) {",
            "//     if (a.first < b.first)",
            "//         return b;",
            "//     else",
            "//         return a;",
            "// });"
        ],
        "description": ""
    },
    "./data_structures/weighted_unionfind.cpp": {
        "prefix": "snp weighted_unionfind",
        "body": [
            "",
            "// WeightedUnionFind",
            "// \u901a\u5e38\u306eUnionFind\u306b\u52a0\u3048\u3066, \u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u3044\u308b\u30ce\u30fc\u30c9\u306e\u89aa\u306b\u5bfe\u3059\u308b\u91cd\u307f\u3082",
            "// \u7ba1\u7406\u3059\u308b\u30c7\u30fc\u30bf\u69cb\u9020.",
            "template <typename Abel, Abel unit>",
            "struct WeightedUnionFind {",
            "    int n;",
            "    vector<int> parents;",
            "    vector<Abel> diff_weight;",
            "",
            "    WeightedUnionFind(int n) : n(n) {",
            "        parents.assign(n, -1);",
            "        diff_weight.assign(n, unit);",
            "    }",
            "",
            "    // find",
            "    // x\u306e\u89aa\u3092\u8fd4\u3059. \u7d4c\u8def\u5727\u7e2e\u3059\u308b\u305f\u3081, diff_weight\u3082\u66f4\u65b0\u3059\u308b",
            "    // \u5236\u7d04: 0 <= x < n",
            "    int find(int x) {",
            "        if (parents[x] < 0)",
            "            return x;",
            "        else {",
            "            int p = find(parents[x]);",
            "            diff_weight[x] += diff_weight[parents[x]];",
            "            return parents[x] = p;",
            "        }",
            "    }",
            "",
            "    // weight",
            "    // x\u306eparent\u304b\u3089\u306e\u91cd\u307f\u3092\u8fd4\u3059",
            "    // \u5236\u7d04: 0 <= x < n",
            "    Abel weight(int x) {",
            "        find(x);",
            "        return diff_weight[x];",
            "    }",
            "",
            "    // diff",
            "    // x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u3044\u308b\u6642, x\u306b\u5bfe\u3059\u308by\u306e\u91cd\u307f\u3092\u8fd4\u3059.",
            "    // x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u3044\u306a\u3044\u6642, \u8fd4\u3059\u5024\u306b\u306f\u610f\u5473\u304c\u306a\u3044.",
            "    // \u5236\u7d04: 0 <= x,y < n, x\u3068y\u306f\u540c\u3058\u30b0\u30eb\u30fc\u30d7",
            "    Abel diff(int x, int y) {",
            "        return weight(y) - weight(x);",
            "    }",
            "",
            "    // unite",
            "    // weight(y) = weight(x) + w\u3068\u306a\u308b\u3088\u3046\u306bx\u3068y\u3092\u4f75\u5408\u3059\u308b.",
            "    // \u3082\u3057\u3059\u3067\u306bx\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u3067weight(y) != weight(x) + w\u3067\u3042\u308c\u3070false\u3092\u8fd4\u3059.",
            "    // \u305d\u3046\u3067\u306a\u3044\u5834\u5408\u306ftrue\u3092\u8fd4\u3059.",
            "    // \u5236\u7d04: 0 <= x,y < n",
            "    bool unite(int x, int y, Abel w) {",
            "        w += weight(x);",
            "        w -= weight(y);",
            "",
            "        x = find(x);",
            "        y = find(y);",
            "        if (x == y) {",
            "            if (diff(x, y) == w)",
            "                return true;",
            "            else",
            "                return false;",
            "        }",
            "",
            "        if (parents[x] > parents[y]) {",
            "            swap(x, y);",
            "            w *= -1;",
            "        }",
            "",
            "        parents[x] += parents[y];",
            "        parents[y]     = x;",
            "        diff_weight[y] = w;",
            "        return true;",
            "    }",
            "",
            "    // same",
            "    // x\u3068y\u304c\u540c\u3058\u304b\u3069\u3046\u304b\u5224\u5b9a\u3059\u308b",
            "    // \u5236\u7d04: 0 <= x,y < n",
            "    bool same(int x, int y) {",
            "        return find(x) == find(y);",
            "    }",
            "",
            "    // size",
            "    // x\u3068\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306e\u30b5\u30a4\u30ba\u3092\u8fd4\u3059.",
            "    // \u5236\u7d04: 0 <= x < n",
            "    int size(int x) {",
            "        return -parents[find(x)];",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./data_structures/segment_tree.cpp": {
        "prefix": "snp segment_tree",
        "body": [
            "",
            "// SegmentTree",
            "// Mon\u306f\u30e2\u30ce\u30a4\u30c9, \u3059\u306a\u308f\u3061 *: Mon \u00d7 Mon -> Mon\u306a\u308b\u6f14\u7b97\u3068e(\u5358\u4f4d\u5143)\u304c\u3042\u3063\u3066,",
            "// \u4ee5\u4e0b\u3092\u6e80\u305f\u3059\u3082\u306e.",
            "// - e * a = a * e = a",
            "// - a * (b * c) = (a * b) * c",
            "//",
            "// \u4ee5\u4e0b\u306e\u4e8c\u3064\u306e\u64cd\u4f5c\u304c\u3067\u304d\u308b.",
            "// 1. A[x]\u3092\u66f4\u65b0\u3059\u308b",
            "// 2. A[l]*...*A[r-1] \u3092\u8a08\u7b97\u3059\u308b",
            "template <typename Mon>",
            "struct SegmentTree {",
            "    using Fx = function<Mon(Mon, Mon)>;",
            "",
            "    int n;",
            "    int size;",
            "    vector<Mon> tree;",
            "    Fx op;",
            "    Mon e;",
            "",
            "    SegmentTree(int n, Fx op, Mon e) : n(n), op(op), e(e) {",
            "        size = 1;",
            "        while (size < n)",
            "            size <<= 1;",
            "        tree.assign(2 * size, e);",
            "    }",
            "",
            "    // build",
            "    // array\u3067\u521d\u671f\u5316\u3059\u308b.",
            "    void build(vector<Mon> &array) {",
            "        for (int i = size; i < size + n; i++)",
            "            tree[i] = array[i - size];",
            "        for (int i = size - 1; i > 0; i--)",
            "            tree[i] = op(tree[i << 1], tree[i << 1 | 1]);",
            "    }",
            "",
            "    // update",
            "    // A[k] = A[k] * x \u3068\u66f4\u65b0\u3059\u308b",
            "    // \u5236\u7d04: 0 <= k < n",
            "    // \u8a08\u7b97\u91cf: O(logn)",
            "    void update(int k, Mon x) {",
            "        k += size;",
            "        tree[k] = op(tree[k], x);",
            "        while (k > 1) {",
            "            k >>= 1;",
            "            tree[k] = op(tree[k << 1], tree[k << 1 | 1]);",
            "        }",
            "    }",
            "",
            "    // set",
            "    // A[k] = x \u3068\u66f4\u65b0\u3059\u308b",
            "    // \u5236\u7d04: 0 <= k < n",
            "    // \u8a08\u7b97\u91cf: O(logn)",
            "    void set(int k, Mon x) {",
            "        k += size;",
            "        tree[k] = x;",
            "        while (k > 1) {",
            "            k >>= 1;",
            "            tree[k] = op(tree[k << 1], tree[k << 1 | 1]);",
            "        }",
            "    }",
            "",
            "    // get",
            "    // A[k]\u3092\u8fd4\u3059.",
            "    // \u5236\u7d04: 0 <= k < n",
            "    // \u8a08\u7b97\u91cf: O(1)",
            "    Mon get(int k) {",
            "        return tree[k + size];",
            "    }",
            "",
            "    // prod",
            "    // A[l]*...*A[r-1] \u3092\u8a08\u7b97\u3059\u308b. l = r\u306e\u3068\u304d\u306fe\u3092\u8fd4\u3059.",
            "    // \u5236\u7d04: 0 <= l <= r <= n",
            "    // \u8a08\u7b97\u91cf: O(logn)",
            "    Mon prod(int l, int r) {",
            "        l += size;",
            "        r += size;",
            "        Mon vl = e, vr = e;",
            "        while (l < r) {",
            "            if (l & 1) {",
            "                vl = op(vl, tree[l]);",
            "                l++;",
            "            }",
            "            if (r & 1) {",
            "                r--;",
            "                vr = op(tree[r], vr);",
            "            }",
            "            l >>= 1;",
            "            r >>= 1;",
            "        }",
            "        return op(vl, vr);",
            "    }",
            "",
            "    // max_right",
            "    // l < r <= n\u3067f(A[l]*...*A[r-1]) = true\u306a\u308b\u6700\u5927\u306er, \u305d\u306e\u3088\u3046\u306ar\u304c\u5b58\u5728\u3057\u306a\u3044\u5834\u5408\u306fl\u3092\u8fd4\u3059.",
            "    // \u5236\u7d04: 0 <= l <= n,f(e) = true",
            "    // \u8a08\u7b97\u91cf: O(logn)",
            "    int max_right(int l, function<bool(Mon)> f) {",
            "        if (l == n) return n;",
            "        int r = l + size;",
            "        Mon x = e;",
            "        do {",
            "            while (r % 2 == 0)",
            "                r >>= 1;",
            "            if (f(op(x, tree[r]))) {",
            "                x = op(x, tree[r]);",
            "                r++;",
            "            } else {",
            "                while (r < size) {",
            "                    r <<= 1;",
            "                    if (f(op(x, tree[r]))) {",
            "                        x = op(x, tree[r]);",
            "                        r++;",
            "                    }",
            "                }",
            "                return r - size;",
            "            }",
            "        } while ((r & -r) != r);",
            "        return n;",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./data_structures/binary_indexed_tree.cpp": {
        "prefix": "snp binary_indexed_tree",
        "body": [
            "",
            "// BinaryIndexedTree",
            "// \u53ef\u63db\u7fa4T\u306b\u3064\u3044\u3066\u4ee5\u4e0b\u306e\u4e8c\u3064\u306e\u64cd\u4f5c\u304c\u53ef\u80fd",
            "//",
            "// 1. A[0] + A[1] + ... + A[k] \u3092\u6c42\u3081\u308b.",
            "// 2. A[k] += x \u3068\u66f4\u65b0.",
            "//",
            "template <typename T>",
            "struct BinaryIndexedTree {",
            "    int n, size;",
            "    int power;",
            "    vector<T> data;",
            "",
            "    BinaryIndexedTree(int n) : n(n) {",
            "        size = 1;",
            "        while (size < n)",
            "            size <<= 1;",
            "        data.assign(size + 1, 0);",
            "    }",
            "",
            "    // build",
            "    // A\u3067\u521d\u671f\u5316",
            "    void build(const vector<T> &A) {",
            "        for (int i = 0; i < n; ++i)",
            "            add(i, A[i]);",
            "    }",
            "",
            "    // add",
            "    // A[k]\u306bx\u3092\u52a0\u3048\u308b.",
            "    // \u5236\u7d04: 0 <= k < n",
            "    // \u8a08\u7b97\u91cf: O(logn)",
            "    void add(int k, T x) {",
            "        for (int i = ++k; i <= n; i += (i & -i)) {",
            "            data[i] += x;",
            "        }",
            "    }",
            "",
            "    // sum",
            "    // \u03a3_{0 <= i <= k} A[i]\u3092\u6c42\u3081\u308b.",
            "    // \u5236\u7d04: 0 <= k < n (\u305d\u308c\u4ee5\u5916\u306f0\u3092\u8fd4\u3059)",
            "    // \u8a08\u7b97\u91cf: O(logn)",
            "    T sum(int k) {",
            "        if (k < 0) return 0;",
            "        k = min(k, n - 1);",
            "",
            "        T ret = 0;",
            "        for (int i = ++k; i > 0; i -= (i & -i)) {",
            "            ret += data[i];",
            "        }",
            "        return ret;",
            "    }",
            "",
            "    // sum",
            "    // \u03a3_{l <= i < r} A[i]\u3092\u6c42\u3081\u308b.",
            "    // \u5236\u7d04: 0 <= l <= r <= N",
            "    // \u8a08\u7b97\u91cf: O(logN)",
            "    T sum(int l, int r) {",
            "        return sum(r - 1) - sum(l - 1);",
            "    }",
            "",
            "    // lower_bound",
            "    // \u03a3_{0 <= i <= k} >= x \u3092\u6e80\u305f\u3059\u6700\u5c0f\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9k\u3092\u8fd4\u3059. \u305d\u306e\u3088\u3046\u306a\u3082\u306e\u304c\u5b58\u5728\u3057\u306a\u3051\u308c\u3070n\u3092\u8fd4\u3059.",
            "    // \u5236\u7d04: A[i] >= 0",
            "    // \u8a08\u7b97\u91cf: O(logN)",
            "    int lower_bound(T x) {",
            "        int k = 0;",
            "        for (int r = size; r > 0; r >>= 1) {",
            "            if (k + r <= size && data[k + r] < x) {",
            "                x -= data[k + r];",
            "                k += r;",
            "            }",
            "        }",
            "        return min(k, n);",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./data_structures/unionfind.cpp": {
        "prefix": "snp unionfind",
        "body": [
            "",
            "// UnionFind",
            "// \u30b0\u30eb\u30fc\u30d7\u3092\u7ba1\u7406\u3059\u308b\u30c7\u30fc\u30bf\u69cb\u9020",
            "struct UnionFind {",
            "    int n;",
            "    vector<int> parents;",
            "",
            "    UnionFind(int n) : n(n) {",
            "        parents.assign(n, -1);",
            "    }",
            "",
            "    // find",
            "    // x\u306e\u89aa\u3092\u8fd4\u3059.",
            "    // \u5236\u7d04: 0 <= x < n",
            "    int find(int x) {",
            "        if (parents[x] < 0) return x;",
            "        return parents[x] = find(parents[x]);",
            "    }",
            "",
            "    // unite",
            "    // x\u3068y\u3092\u542b\u3080\u30b0\u30eb\u30fc\u30d7\u3092\u4f75\u5408",
            "    // \u5236\u7d04: 0 <= x,y < n",
            "    void unite(int x, int y) { // x\u3068y\u306e\u542b\u3080\u30b0\u30eb\u30fc\u30d7\u3092\u4f75\u5408",
            "        int px = find(x);",
            "        int py = find(y);",
            "        if (parents[px] > parents[py]) swap(px, py);",
            "        if (px != py) {",
            "            parents[px] += parents[py];",
            "            parents[py] = px;",
            "        }",
            "    }",
            "",
            "    // same",
            "    // x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u3044\u308b\u304b\u5224\u5b9a",
            "    // \u5236\u7d04: 0 <= x,y < n",
            "    bool same(int x, int y) {",
            "        return find(x) == find(y);",
            "    }",
            "",
            "    // size",
            "    // x\u3068\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306e\u30e1\u30f3\u30d0\u30fc\u306e\u500b\u6570",
            "    // \u5236\u7d04: 0 <= x < n",
            "    int size(int x) {",
            "        return -parents[find(x)];",
            "    }",
            "",
            "    // root",
            "    // \u6839\u3092\u5168\u3066\u5217\u6319\u3059\u308b",
            "    vector<int> root() {",
            "        vector<int> res;",
            "        for (int i = 0; i < n; i++) {",
            "            if (parents[i] < 0) res.push_back(i);",
            "        }",
            "        return res;",
            "    }",
            "",
            "    // group_count",
            "    // \u30b0\u30eb\u30fc\u30d7\u306e\u6570\u3092\u8fd4\u3059.",
            "    int group_count() { // uf\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u6570\u3092\u6570\u3048\u308b",
            "        return (int)root().size();",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./data_structures/lazy_segment_tree.cpp": {
        "prefix": "snp lazy_segment_tree",
        "body": [
            "",
            "// LazySegmentTree",
            "// *: Mon \u00d7 Mon -> Mon\u306f\u30e2\u30ce\u30a4\u30c9\u3067\u3042\u308a, e\u3092Mon\u306e\u5358\u4f4d\u5143",
            "// \u00d7: OpMon \u00d7 OpMon -> OpMon\u306f\u30e2\u30ce\u30a4\u30c9\u3067\u3042\u308a, id\u3092OpMon\u306e\u5358\u4f4d\u5143 \u3068\u3059\u308b.",
            "// ^: Mon \u00d7 OpMon -> Mon \u306a\u308bMon\u3078\u306e\u53f3\u4f5c\u7528\u306f\u6b21\u306e\u6027\u8cea\u3092\u6e80\u305f\u3059\u3068\u3059\u308b.",
            "//",
            "// 1. x^id = x",
            "// 2. (x * y)^a = x^a * y^a",
            "// 3. (x^a)^b = x^(a \u00d7 b)",
            "//",
            "// \u3053\u306e\u3068\u304d, \u4ee5\u4e0b\u306e\u64cd\u4f5c\u304c\u53ef\u80fd",
            "// 1. A[l]*...*A[r-1]\u3092\u6c42\u3081\u308b",
            "// 2. A[i] = A[i]^a (l <= i < r)\u3068\u66f4\u65b0\u3059\u308b",
            "template <typename Mon, typename OpMon>",
            "struct LazySegmentTree {",
            "    using Fx  = function<Mon(Mon, Mon)>;",
            "    using Fop = function<Mon(Mon, OpMon)>;",
            "    using Fy  = function<OpMon(OpMon, OpMon)>;",
            "",
            "    int n, size, log;",
            "    vector<Mon> data;",
            "    vector<OpMon> lazy; // lazy[i] = i\u81ea\u8eab\u3068i\u306e\u5b50\u5b6b\u306b\u3053\u308c\u304b\u3089\u4f1d\u64ad\u3057\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\u5024",
            "",
            "    Fx op;",
            "    Mon e;",
            "    Fy composition;",
            "    OpMon id;",
            "    Fop mapping;",
            "",
            "    LazySegmentTree(int n, Fx op, Mon e, Fy composition, OpMon id, Fop mapping)",
            "        : n(n), op(op), e(e), composition(composition), id(id), mapping(mapping) {",
            "        size = 1, log = 0;",
            "        while (size < n)",
            "            size <<= 1, log++;",
            "        data.assign(2 * size, e);",
            "        lazy.assign(2 * size, id);",
            "    }",
            "",
            "    // build",
            "    // \u9577\u3055n\u306e\u914d\u5217A\u3067\u521d\u671f\u5316\u3059\u308b.",
            "    // \u8a08\u7b97\u91cf: O(n)",
            "    void build(vector<Mon> &A) {",
            "        for (int i = size; i < size + n; i++)",
            "            data[i] = A[i - size];",
            "        for (int i = size - 1; i >= 1; i--)",
            "            data[i] = op(data[i << 1], data[i << 1 | 1]);",
            "    }",
            "",
            "    // apply",
            "    // A[i] = A[i] * x (l <= i < r)\u3068\u3059\u308b.",
            "    // \u5236\u7d04: 0 <= l <= r <= n",
            "    // \u8a08\u7b97\u91cf: O(logn)",
            "    void apply(int l, int r, OpMon x) {",
            "        l += size;",
            "        r += size;",
            "        int tmp_l = l, tmp_r = r;",
            "        propagate_above(l);",
            "        propagate_above(r - 1);",
            "        while (l < r) {",
            "            if (l & 1) {",
            "                lazy[l] = composition(lazy[l], x);",
            "                l++;",
            "            }",
            "            if (r & 1) {",
            "                r--;",
            "                lazy[r] = composition(lazy[r], x);",
            "            }",
            "            l >>= 1;",
            "            r >>= 1;",
            "        }",
            "        recalc_above(tmp_l);",
            "        recalc_above(tmp_r - 1);",
            "    }",
            "",
            "    // prod",
            "    // A[l]*...*A[r-1]\u3092\u8fd4\u3059. l = r\u306a\u3089e\u3092\u8fd4\u3059.",
            "    // \u5236\u7d04: 0 <= l <= r <= n",
            "    // \u8a08\u7b97\u91cf; O(logn)",
            "    Mon prod(int l, int r) {",
            "        l += size;",
            "        r += size;",
            "        propagate_above(l);",
            "        propagate_above(r - 1);",
            "        Mon vl = e, vr = e;",
            "        while (l < r) {",
            "            if (l & 1) {",
            "                vl = op(vl, propagate(l));",
            "                l++;",
            "            }",
            "            if (r & 1) {",
            "                r--;",
            "                vr = op(propagate(r), vr);",
            "            }",
            "            l >>= 1;",
            "            r >>= 1;",
            "        }",
            "        return op(vl, vr);",
            "    }",
            "",
            "  private:",
            "    // propagate",
            "    // lazy[i]\u3092data[i]\u306b\u53cd\u6620\u3055\u305b, i\u306e\u5b50\u304c\u3042\u308c\u3070\u305d\u306elazy\u306e\u66f4\u65b0\u3092\u3059\u308b.",
            "    // \u66f4\u65b0\u3057\u305fdata[i]\u3092\u8fd4\u3059.",
            "    Mon propagate(int i) {",
            "        data[i] = mapping(data[i], lazy[i]);",
            "        if (i < size) {",
            "            lazy[i << 1]     = composition(lazy[i << 1], lazy[i]);",
            "            lazy[i << 1 | 1] = composition(lazy[i << 1 | 1], lazy[i]);",
            "        }",
            "        lazy[i] = id;",
            "        return data[i];",
            "    }",
            "    // propagate_above",
            "    // i\u3092\u542b\u3080i\u3088\u308a\u4e0a\u306e\u533a\u9593\u306edata\u3092\u4ee5\u524d\u306e\u30c7\u30fc\u30bf\u3092\u4f1d\u64ad\u3059\u308b\u3053\u3068\u3067\u6b63\u3057\u3044\u72b6\u614b\u306b\u3059\u308b.",
            "    void propagate_above(int i) {",
            "        for (int k = log; k >= 0; k--)",
            "            if ((i >> k) >= 1) propagate(i >> k);",
            "    }",
            "    // recalc_above",
            "    // i\u3092\u542b\u307e\u306a\u3044i\u3088\u308a\u4e0a\u306e\u533a\u9593\u306edata\u3092\u3044\u307e\u66f4\u65b0\u3055\u308c\u305fdata\u3092\u7528\u3044\u3066\u6b63\u3057\u3044\u72b6\u614b\u306b\u4fdd\u3064.",
            "    void recalc_above(int i) {",
            "        while (i > 1) {",
            "            i >>= 1;",
            "            data[i] = op(propagate(i << 1), propagate(i << 1 | 1));",
            "        }",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./math/matrix.cpp": {
        "prefix": "snp matrix",
        "body": [
            "",
            "",
            "template <int MOD>",
            "struct ModInt {",
            "  public:",
            "    long long x;",
            "    ModInt(long long x = 0) : x((x % MOD + MOD) % MOD) {}",
            "    constexpr ModInt &operator+=(const ModInt a) noexcept {",
            "        if ((x += a.x) >= MOD) x -= MOD;",
            "        return *this;",
            "    }",
            "    constexpr ModInt &operator-=(const ModInt a) noexcept {",
            "        if ((x += MOD - a.x) >= MOD) x -= MOD;",
            "        return *this;",
            "    }",
            "    constexpr ModInt &operator*=(const ModInt a) noexcept {",
            "        (x *= a.x) %= MOD;",
            "        return *this;",
            "    }",
            "    constexpr ModInt &operator/=(const ModInt a) noexcept { return *this *= a.inverse(); }",
            "",
            "    constexpr ModInt operator+(const ModInt a) const noexcept { return ModInt(*this) += a.x; }",
            "    constexpr ModInt operator-(const ModInt a) const noexcept { return ModInt(*this) -= a.x; }",
            "    constexpr ModInt operator*(const ModInt a) const noexcept { return ModInt(*this) *= a.x; }",
            "    constexpr ModInt operator/(const ModInt a) const noexcept { return ModInt(*this) /= a.x; }",
            "",
            "    friend constexpr std::ostream &operator<<(std::ostream &os, const ModInt<MOD> a) noexcept { return os << a.x; }",
            "    friend constexpr std::istream &operator>>(std::istream &is, ModInt<MOD> &a) noexcept { return is >> a.x; }",
            "",
            "    ModInt inverse() const noexcept { // x ^ (-1)",
            "        long long a = x, b = MOD, p = 1, q = 0;",
            "        while (b) {",
            "            long long d = a / b;",
            "            a -= d * b;",
            "            swap(a, b);",
            "            p -= d * q;",
            "            swap(p, q);",
            "        }",
            "        return ModInt(p);",
            "    }",
            "    ModInt pow(long long N) const noexcept { // x ^ N",
            "        ModInt a = 1;",
            "        ModInt y = this->x;",
            "        while (N) {",
            "            if (N & 1) a *= y;",
            "            y *= y;",
            "            N >>= 1;",
            "        }",
            "        return a;",
            "    }",
            "};",
            "",
            "template <typename U, int MOD>",
            "inline ModInt<MOD> operator*(const U &c, const ModInt<MOD> &a) { return {c * a.x}; }",
            "",
            "using mint = ModInt<998244353>;",
            "",
            "template <typename T>",
            "using Matrix = vector<vector<T>>;",
            "",
            "template <typename T>",
            "Matrix<T> mul(const Matrix<T> &a, const Matrix<T> &b) {",
            "    assert(a[0].size() == b.size());",
            "    Matrix<T> c(a.size(), vector<T>(b[0].size()));",
            "    for (int i = 0; i < (int)a.size(); i++) {",
            "        for (int j = 0; j < (int)a[0].size(); j++) {",
            "            for (int k = 0; k < (int)b[0].size(); k++) {",
            "                c[i][k] += a[i][j] * b[j][k];",
            "            }",
            "        }",
            "    }",
            "    return c;",
            "}",
            "",
            "template <typename T>",
            "vector<T> mul(const Matrix<T> &a, const vector<T> &b) {",
            "    assert(a[0].size() == b.size());",
            "    vector<T> ans(a.size(), 0);",
            "    for (int i = 0; i < (int)a.size(); i++) {",
            "        for (int j = 0; j < (int)a[0].size(); j++) {",
            "            ans[i] += a[i][j] * b[j];",
            "        }",
            "    }",
            "    return ans;",
            "}",
            "",
            "template <typename T, typename U>",
            "Matrix<T> pow(Matrix<T> a, U n) {",
            "    assert(a.size() == a[0].size());",
            "    int m = (int)a.size();",
            "    Matrix<T> ans(m, vector<T>(m, 0));",
            "    for (int i = 0; i < m; i++)",
            "        ans[i][i] = 1;",
            "    while (n > 0) {",
            "        if (n & 1) {",
            "            ans = mul(ans, a);",
            "        }",
            "        a = mul(a, a);",
            "        n >>= 1;",
            "    }",
            "    return ans;",
            "}",
            "",
            "template <int MOD>",
            "int _find_pivot(const Matrix<ModInt<MOD>> &a, int i) {",
            "    for (int j = i; j < (int)a[i].size(); j++) {",
            "        if (a[j][i].x != 0) return j;",
            "    }",
            "    return -1;",
            "}",
            "",
            "template <typename T>",
            "int _find_pivot(const Matrix<T> &a, int i) {",
            "    int pivot = -1;",
            "    T val     = T(0);",
            "    for (int j = i; j < (int)a[i].size(); j++) {",
            "        if (abs(a[j][i]) > val) {",
            "            val   = abs(a[j][i]);",
            "            pivot = j;",
            "        }",
            "    }",
            "    return pivot;",
            "}",
            "",
            "// lu_decomposition",
            "// PA = LU\u306a\u308b\u5206\u89e3\u3092\u3059\u308b. \u305f\u3060\u3057, P\u306f\u7f6e\u63db\u884c\u5217, L\u306f\u5bfe\u89d2\u6210\u5206\u304c1\u306e\u4e0b\u4e09\u89d2\u884c\u5217, U\u306f\u4e0a\u4e09\u89d2\u884c\u5217.",
            "// \u7f6e\u63dbP\u3068L,U\u3092\u8a70\u3081\u305f\u884c\u5217\u3092\u8fd4\u3059. A\u304c\u6b63\u5247\u3067\u306f\u306a\u3044\u5834\u5408, U\u306e\u5bfe\u89d2\u6210\u5206\u306b0\u304c\u542b\u307e\u308c\u308b.",
            "// \u8a08\u7b97\u91cf: O(n^3)",
            "template <typename T>",
            "pair<vector<int>, Matrix<T>> lu_decomposition(Matrix<T> a) {",
            "    assert(a.size() == a[0].size());",
            "    int n = (int)a.size();",
            "    vector<int> pinv(n);",
            "    iota(pinv.begin(), pinv.end(), 0);",
            "    for (int i = 0; i < n; i++) {",
            "        int pivot = _find_pivot(a, i);",
            "        if (pivot < 0) continue;",
            "        swap(a[i], a[pivot]), swap(pinv[i], pinv[pivot]);",
            "        for (int j = i + 1; j < n; j++) {",
            "            a[j][i] /= a[i][i];",
            "            for (int k = i + 1; k < n; k++) {",
            "                a[j][k] -= a[i][k] * a[j][i];",
            "            }",
            "        }",
            "    }",
            "    vector<int> p(n);",
            "    iota(p.begin(), p.end(), 0);",
            "    for (int i = 0; i < n; i++) {",
            "        if (i == pinv[i]) continue;",
            "        int k = -1;",
            "        for (int j = i + 1; j < n; j++) {",
            "            if (pinv[j] == i) k = j;",
            "        }",
            "        swap(p[i], p[k]);",
            "        swap(pinv[i], pinv[k]);",
            "    }",
            "    return make_pair(p, a);",
            "}",
            "",
            "constexpr inline bool _is_zero(long double x) { return abs(x) < 1e-8; }",
            "constexpr inline bool _is_zero(double x) { return abs(x) < 1e-8; }",
            "template <int MOD>",
            "constexpr inline bool _is_zero(const ModInt<MOD> &x) { return x.x == 0; }",
            "template <typename T>",
            "constexpr inline bool _is_zero(T x) { return x == T(0); }",
            "",
            "// solve",
            "// PA = LU\u3092\u7528\u3044\u3066Ax = b\u306a\u308b\u9023\u7acb\u65b9\u7a0b\u5f0f\u3092\u3068\u304f.",
            "// \u3082\u3057\u89e3\u304c\u5b58\u5728\u3057\u306a\u3051\u308c\u3070{}\u3092\u8fd4\u3059. \u89e3\u304c\u5c11\u306a\u304f\u3068\u3082\u4e00\u3064\u5b58\u5728\u3059\u308c\u3070\u305d\u306e\u4e00\u3064\u3092\u8fd4\u3059.",
            "// \u8a08\u7b97\u91cf: O(n^2)",
            "template <typename T>",
            "vector<T> solve(vector<int> p, const Matrix<T> &lu, vector<T> b) {",
            "    int n = (int)lu.size();",
            "    for (int i = 0; i < n; i++) {",
            "        if (i == p[i]) continue;",
            "        int k = -1;",
            "        for (int j = i + 1; j < n; j++) {",
            "            if (p[j] == i) k = j;",
            "        }",
            "        swap(p[i], p[k]);",
            "        swap(b[i], b[k]);",
            "    }",
            "    for (int i = 0; i < n; i++)",
            "        for (int j = 0; j < i; j++)",
            "            b[i] -= b[j] * lu[i][j];",
            "    for (int i = n - 1; i >= 0; i--) {",
            "        for (int j = i + 1; j < n; j++)",
            "            b[i] -= b[j] * lu[i][j];",
            "        if (_is_zero(lu[i][i]) && !_is_zero(b[i]))",
            "            return {}; // \u89e3\u306a\u3057",
            "        else if (!_is_zero(lu[i][i]))",
            "            b[i] /= lu[i][i];",
            "    }",
            "    return b;",
            "}",
            "",
            "// solve",
            "// Ax = b\u306a\u308b\u9023\u7acb\u65b9\u7a0b\u5f0f\u3092\u3068\u304f.",
            "// \u3082\u3057\u89e3\u304c\u5b58\u5728\u3057\u306a\u3051\u308c\u3070{}\u3092\u8fd4\u3059. \u89e3\u304c\u5c11\u306a\u304f\u3068\u3082\u4e00\u3064\u5b58\u5728\u3059\u308c\u3070\u305d\u306e\u4e00\u3064\u3092\u8fd4\u3059.",
            "// \u8a08\u7b97\u91cf: O(n^3)",
            "template <typename T>",
            "vector<T> solve(Matrix<T> A, vector<T> b) {",
            "    assert(A.size() == A[0].size());",
            "    auto [p, lu] = lu_decomposition(A);",
            "    return solve(p, lu, b);",
            "}",
            "",
            "// _det",
            "// lu\u5206\u89e3\u3055\u308c\u305f\u884c\u5217\u306e\u884c\u5217\u5f0f\u3092\u6c42\u3081\u308b.",
            "// \u8a08\u7b97\u91cf: O(n)",
            "template <typename T>",
            "T _det(const Matrix<T> &lu) {",
            "    T ans = T(1);",
            "    for (int i = 0; i < (int)lu.size(); i++)",
            "        ans *= lu[i][i];",
            "    return ans;",
            "}",
            "",
            "// det",
            "// \u884c\u5217\u306e\u884c\u5217\u5f0f\u3092\u6c42\u3081\u308b.",
            "// \u8a08\u7b97\u91cf: O(n^3)",
            "template <typename T>",
            "T det(Matrix<T> A) {",
            "    auto [_, lu] = lu_decomposition(A);",
            "    return _det(lu);",
            "}",
            "",
            "// _rank",
            "// lu\u5206\u89e3\u3055\u308c\u305f\u884c\u5217\u306e\u30e9\u30f3\u30af\u3092\u6c42\u3081\u308b.",
            "// \u8a08\u7b97\u91cf: O(n)",
            "template <typename T>",
            "int _rank(const Matrix<T> &lu) {",
            "    int ans = (int)lu.size();",
            "    for (int i = 0; i < (int)lu.size(); i++)",
            "        if (_is_zero(lu[i][i])) ans--;",
            "    return ans;",
            "}",
            "",
            "// rank",
            "// \u884c\u5217\u306e\u30e9\u30f3\u30af\u3092\u6c42\u3081\u308b.",
            "// \u8a08\u7b97\u91cf: O(n^3)",
            "template <typename T>",
            "int rank(Matrix<T> A) {",
            "    auto [_, lu] = lu_decomposition(A);",
            "    return _rank(lu);",
            "}"
        ],
        "description": ""
    },
    "./math/fast_fourier_transform.cpp": {
        "prefix": "snp fast_fourier_transform",
        "body": [
            "",
            "template <int MOD>",
            "struct ModInt {",
            "  public:",
            "    long long x;",
            "    ModInt(long long x = 0) : x((x % MOD + MOD) % MOD) {}",
            "    constexpr ModInt &operator+=(const ModInt a) noexcept {",
            "        if ((x += a.x) >= MOD) x -= MOD;",
            "        return *this;",
            "    }",
            "    constexpr ModInt &operator-=(const ModInt a) noexcept {",
            "        if ((x += MOD - a.x) >= MOD) x -= MOD;",
            "        return *this;",
            "    }",
            "    constexpr ModInt &operator*=(const ModInt a) noexcept {",
            "        (x *= a.x) %= MOD;",
            "        return *this;",
            "    }",
            "    constexpr ModInt &operator/=(const ModInt a) noexcept { return *this *= a.inverse(); }",
            "",
            "    constexpr ModInt operator+(const ModInt a) const noexcept { return ModInt(*this) += a.x; }",
            "    constexpr ModInt operator-(const ModInt a) const noexcept { return ModInt(*this) -= a.x; }",
            "    constexpr ModInt operator*(const ModInt a) const noexcept { return ModInt(*this) *= a.x; }",
            "    constexpr ModInt operator/(const ModInt a) const noexcept { return ModInt(*this) /= a.x; }",
            "",
            "    friend constexpr std::ostream &operator<<(std::ostream &os, const ModInt<MOD> a) noexcept { return os << a.x; }",
            "    friend constexpr std::istream &operator>>(std::istream &is, ModInt<MOD> &a) noexcept { return is >> a.x; }",
            "",
            "    ModInt inverse() const noexcept { // x ^ (-1)",
            "        long long a = x, b = MOD, p = 1, q = 0;",
            "        while (b) {",
            "            long long d = a / b;",
            "            a -= d * b;",
            "            swap(a, b);",
            "            p -= d * q;",
            "            swap(p, q);",
            "        }",
            "        return ModInt(p);",
            "    }",
            "    ModInt pow(long long N) const noexcept { // x ^ N",
            "        ModInt a = 1;",
            "        ModInt y = this->x;",
            "        while (N) {",
            "            if (N & 1) a *= y;",
            "            y *= y;",
            "            N >>= 1;",
            "        }",
            "        return a;",
            "    }",
            "};",
            "",
            "template <typename U, int MOD>",
            "inline ModInt<MOD> operator*(const U &c, const ModInt<MOD> &a) { return {c * a.x}; }",
            "",
            "using mint = ModInt<998244353>;",
            "",
            "class FastFourierTransform {",
            "  private:",
            "    inline static void fft(vector<complex<double>> &F) {",
            "        int degree = F.size();",
            "        if (degree == 1) return;",
            "        vector<complex<double>> even, odd;",
            "        for (int i = 0; i < degree / 2; i++) {",
            "            even.push_back(F[i << 1]);",
            "            odd.push_back(F[i << 1 | 1]);",
            "        }",
            "        fft(even);",
            "        fft(odd);",
            "        complex<double> x = 1, zeta = polar(1.0, 2 * PI / degree);",
            "        for (int i = 0; i < degree; i++) {",
            "            F[i] = even[i % (degree / 2)] + x * odd[i % (degree / 2)];",
            "            x *= zeta;",
            "        }",
            "    }",
            "",
            "    inline static void ifft(vector<complex<double>> &F) {",
            "        int degree = F.size();",
            "        if (degree == 1) return;",
            "        vector<complex<double>> even, odd;",
            "        for (int i = 0; i < degree / 2; i++) {",
            "            even.push_back(F[i << 1]);",
            "            odd.push_back(F[i << 1 | 1]);",
            "        }",
            "        ifft(even);",
            "        ifft(odd);",
            "        complex<double> x = 1, zeta = polar(1.0, -2 * PI / degree);",
            "        for (int i = 0; i < degree; i++) {",
            "            F[i] = even[i % (degree / 2)] + x * odd[i % (degree / 2)];",
            "            x *= zeta;",
            "        }",
            "    }",
            "",
            "  public:",
            "    template <class T>",
            "    inline static vector<double> multiply(vector<T> F, vector<T> G) {",
            "        int degree = 1;",
            "        while (degree < F.size() + G.size() - 1)",
            "            degree *= 2;",
            "        vector<complex<double>> nF(degree, 0), nG(degree, 0);",
            "        for (int i = 0; i < F.size(); i++)",
            "            nF[i] = F[i];",
            "        for (int i = 0; i < G.size(); i++)",
            "            nG[i] = G[i];",
            "        fft(nF);",
            "        fft(nG);",
            "        for (int i = 0; i < degree; i++) {",
            "            nF[i] *= nG[i];",
            "        }",
            "        ifft(nF);",
            "        vector<double> ret(degree);",
            "        for (int i = 0; i < degree; i++) {",
            "            ret[i] = nF[i].real() / degree;",
            "        }",
            "        return ret;",
            "    }",
            "};",
            "",
            "//\u975e\u518d\u5e30\u3067\u304d\u305f\u306f\u3084\u3044",
            "",
            "class FastFourierTransform {",
            "  private:",
            "    inline static void fft(vector<complex<double>> &F, bool inverse, int bit_len) {",
            "        int degree = F.size();",
            "        for (int i = 0; i < degree; i++) {",
            "            int j = 0;",
            "            for (int k = 0; k < bit_len; k++)",
            "                j |= (i >> k & 1) << (bit_len - k - 1);",
            "            if (i < j) swap(F[i], F[j]);",
            "        }",
            "        for (int b = 1; b < degree; b <<= 1) {",
            "            complex<double> x = 1, zeta = polar(1.0, PI / b * (inverse ? 1 : -1));",
            "            for (int j = 0; j < b; j++) {",
            "                for (int k = 0; k < degree; k += (b << 1)) {",
            "                    complex<double> s = F[j + k], t = F[j + k + b] * x;",
            "                    F[j + k]     = s + t;",
            "                    F[j + k + b] = s - t;",
            "                }",
            "                x *= zeta;",
            "            }",
            "        }",
            "        if (inverse) {",
            "            for (int i = 0; i < degree; i++)",
            "                F[i] /= degree;",
            "        }",
            "    }",
            "",
            "  public:",
            "    template <class T>",
            "    inline static vector<long long> multiply(vector<T> &F, vector<T> &G) {",
            "        int s      = F.size() + G.size() - 1;",
            "        int degree = 1, bit_len = 0;",
            "        while (degree < s)",
            "            degree <<= 1, bit_len++;",
            "        vector<complex<double>> nF(degree, 0), nG(degree, 0);",
            "        for (int i = 0; i < F.size(); i++)",
            "            nF[i] = F[i];",
            "        for (int i = 0; i < G.size(); i++)",
            "            nG[i] = G[i];",
            "        fft(nF, false, bit_len);",
            "        fft(nG, false, bit_len);",
            "        for (int i = 0; i < degree; i++)",
            "            nF[i] *= nG[i];",
            "        fft(nF, true, bit_len);",
            "        vector<long long> ret(s);",
            "        for (int i = 0; i < s; i++)",
            "            ret[i] = (long long)(nF[i].real() + 0.5);",
            "        return ret;",
            "    }",
            "};",
            "",
            "struct NumberTheoreticalTransform {",
            "    const int premitive_root = 3; // primitive root of 998244353",
            "    const int MOD            = 998244353;",
            "    NumberTheoreticalTransform() {}",
            "    inline void ntt(vector<mint> &F, bool inverse, int bit_len) {",
            "        int degree = F.size();",
            "        for (int i = 0; i < degree; i++) {",
            "            int j = 0;",
            "            for (int k = 0; k < bit_len; k++)",
            "                j |= (i >> k & 1) << (bit_len - k - 1);",
            "            if (i < j) swap(F[i], F[j]);",
            "        }",
            "        for (int b = 1; b < degree; b <<= 1) {",
            "            mint x = 1, zeta = mint(premitive_root).pow((MOD - 1) / (b << 1));",
            "            if (inverse) zeta = zeta.inverse();",
            "            for (int j = 0; j < b; ++j) {",
            "                for (int k = 0; k < degree; k += (b << 1)) {",
            "                    mint s = F[j + k], t = F[j + k + b] * x;",
            "                    F[j + k]     = s + t;",
            "                    F[j + k + b] = s - t;",
            "                }",
            "                x *= zeta;",
            "            }",
            "        }",
            "        if (inverse) {",
            "            mint inv = mint(degree).inverse();",
            "            for (int i = 0; i < degree; i++)",
            "                F[i] *= inv;",
            "        }",
            "    }",
            "    inline vector<mint> multiply(vector<mint> &F, vector<mint> &G) {",
            "        int s      = F.size() + G.size() - 1;",
            "        int degree = 1, bit_len = 0;",
            "        while (degree < s)",
            "            degree <<= 1, bit_len++;",
            "        vector<mint> nF(degree, 0), nG(degree, 0);",
            "        for (int i = 0; i < F.size(); i++)",
            "            nF[i] = F[i];",
            "        for (int i = 0; i < G.size(); i++)",
            "            nG[i] = G[i];",
            "        ntt(nF, false, bit_len);",
            "        ntt(nG, false, bit_len);",
            "        for (int i = 0; i < degree; i++)",
            "            nF[i] *= nG[i];",
            "        ntt(nF, true, bit_len);",
            "        return nF;",
            "    }",
            "} ntt;"
        ],
        "description": ""
    },
    "./math/partition_number.cpp": {
        "prefix": "snp partition_number",
        "body": [
            "",
            "// PartionNumber",
            "// n\u500b\u306e\u533a\u5225\u3067\u304d\u306a\u3044\u3082\u306e\u3092k\u500b\u306e\u533a\u5225\u3067\u304d\u306a\u3044\u7bb1\u306b0\u500b\u4ee5\u4e0a\u306b\u5206\u5272\u3059\u308b\u65b9\u6cd5\u304c\u4f55\u901a\u308a\u3042\u308b\u304b\u6c42\u3081\u308b.",
            "// \u3053\u308c\u3092P(n,k)\u3068\u3059\u308b\u3068P(n,0) = 0 (n > 0)",
            "template <typename T>",
            "struct PartitionNumber {",
            "    int n, k;",
            "    vector<vector<T>> dp;",
            "",
            "    PartitionNumber(int n, int k) : n(n), k(k) {",
            "        dp.assign(n + 1, vector<T>(k + 1, T(0)));",
            "    }",
            "",
            "    // solve",
            "    // 0 <= i <= n,0 <= j <= k\u306e\u5206\u5272\u6570\u3092\u6c42\u3081\u308b.",
            "    // \u8a08\u7b97\u91cf: O(nk)",
            "    void solve() {",
            "        dp[0][0] = T(1);",
            "        for (int i = 0; i <= n; i++) {",
            "            for (int j = 1; j <= k; j++) {",
            "                dp[i][j] = dp[i][j - 1];",
            "                if (i - j >= 0) dp[i][j] += dp[i - j][j];",
            "            }",
            "        }",
            "    }",
            "",
            "    // P(i,j)\u3092\u8fd4\u3059.",
            "    // \u5236\u7d04: 0 <= i <= n,0 <= j <= k",
            "    T operator()(int i, int j) {",
            "        return dp[i][j];",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./math/number_theoretic_transform.cpp": {
        "prefix": "snp number_theoretic_transform",
        "body": [
            "",
            "template <int MOD>",
            "struct ModInt {",
            "  public:",
            "    long long x;",
            "    ModInt(long long x = 0) : x((x % MOD + MOD) % MOD) {}",
            "    constexpr ModInt &operator+=(const ModInt a) noexcept {",
            "        if ((x += a.x) >= MOD) x -= MOD;",
            "        return *this;",
            "    }",
            "    constexpr ModInt &operator-=(const ModInt a) noexcept {",
            "        if ((x += MOD - a.x) >= MOD) x -= MOD;",
            "        return *this;",
            "    }",
            "    constexpr ModInt &operator*=(const ModInt a) noexcept {",
            "        (x *= a.x) %= MOD;",
            "        return *this;",
            "    }",
            "    constexpr ModInt &operator/=(const ModInt a) noexcept { return *this *= a.inverse(); }",
            "",
            "    constexpr ModInt operator+(const ModInt a) const noexcept { return ModInt(*this) += a.x; }",
            "    constexpr ModInt operator-(const ModInt a) const noexcept { return ModInt(*this) -= a.x; }",
            "    constexpr ModInt operator*(const ModInt a) const noexcept { return ModInt(*this) *= a.x; }",
            "    constexpr ModInt operator/(const ModInt a) const noexcept { return ModInt(*this) /= a.x; }",
            "",
            "    friend constexpr std::ostream &operator<<(std::ostream &os, const ModInt<MOD> a) noexcept { return os << a.x; }",
            "    friend constexpr std::istream &operator>>(std::istream &is, ModInt<MOD> &a) noexcept { return is >> a.x; }",
            "",
            "    ModInt inverse() const noexcept { // x ^ (-1)",
            "        long long a = x, b = MOD, p = 1, q = 0;",
            "        while (b) {",
            "            long long d = a / b;",
            "            a -= d * b;",
            "            swap(a, b);",
            "            p -= d * q;",
            "            swap(p, q);",
            "        }",
            "        return ModInt(p);",
            "    }",
            "    ModInt pow(long long N) const noexcept { // x ^ N",
            "        ModInt a = 1;",
            "        ModInt y = this->x;",
            "        while (N) {",
            "            if (N & 1) a *= y;",
            "            y *= y;",
            "            N >>= 1;",
            "        }",
            "        return a;",
            "    }",
            "};",
            "",
            "template <typename U, int MOD>",
            "inline ModInt<MOD> operator*(const U &c, const ModInt<MOD> &a) { return {c * a.x}; }",
            "",
            "using mint = ModInt<998244353>;",
            "",
            "// NumberTheoreticTransform supports only F_998244353 as coefficient.",
            "// recursive version",
            "struct NumberTheoreticTransform {",
            "  private:",
            "    const mint ROOT = 3;",
            "    const int MOD   = 998244353;",
            "",
            "  public:",
            "    NumberTheoreticTransform() {}",
            "",
            "    // ntt calculates y[i] = \\sum_{j=0}^{n-1} x[j]r^{ij} where n is length of x and r is n-th root of 1 (mod n)",
            "    // n must be power of two (n = 2^m)",
            "    void ntt(int m, mint nth_root, std::vector<mint> &x) {",
            "        if (m == 0) return;",
            "        int n = (int)x.size();",
            "        assert(n == (1 << m));",
            "",
            "        int n_half = n / 2;",
            "        std::vector<mint> x_e(n_half), x_o(n_half);",
            "        for (int i = 0; i < n_half; i++) {",
            "            x_e[i] = x[i << 1];",
            "            x_o[i] = x[i << 1 | 1];",
            "        }",
            "        ntt(m - 1, nth_root * nth_root, x_e);",
            "        ntt(m - 1, nth_root * nth_root, x_o);",
            "",
            "        mint root_pow = 1;",
            "        int mask      = n_half - 1;",
            "        for (int i = 0; i < n; i++) {",
            "            x[i] = x_e[i & mask] + root_pow * x_o[i & mask];",
            "            root_pow *= nth_root;",
            "        }",
            "    }",
            "",
            "    // multiply calculates f*g, when f[i] is coefficients of x^i (0-indexed) and g[i] is coefficients of x^i (0-indexed)",
            "    std::vector<mint> multiply(std::vector<mint> f, std::vector<mint> g) {",
            "        int min_sz = (int)f.size() + (int)g.size() + 1;",
            "        int m      = 0;",
            "        while ((1 << m) < min_sz) {",
            "            ++m;",
            "        }",
            "        int sz = 1 << m;",
            "        f.resize(sz, (mint)0);",
            "        g.resize(sz, (mint)0);",
            "        assert((MOD - 1) % sz == 0);",
            "",
            "        const mint nth_root = ROOT.pow((long long)(MOD - 1) / sz);",
            "        ntt(m, nth_root, f);",
            "        ntt(m, nth_root, g);",
            "",
            "        std::vector<mint> h(sz);",
            "        for (int i = 0; i < sz; i++) {",
            "            h[i] = f[i] * g[i];",
            "        }",
            "",
            "        ntt(m, nth_root.inverse(), h);",
            "        mint n_inv = mint(sz).inverse();",
            "        for (int i = 0; i < sz; i++) {",
            "            h[i] *= n_inv;",
            "        }",
            "        return h;",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./math/polygon.cpp": {
        "prefix": "snp polygon",
        "body": [
            "",
            "",
            "constexpr long double GEOMETRY_EPS = 1e-8;",
            "",
            "// sgn",
            "// a > 0\u306a\u30891, a = 0\u306a\u30890,a < 0\u306a\u3089-1\u3092\u8fd4\u3059.",
            "constexpr inline int sgn(const long double a) { return (a < -GEOMETRY_EPS ? -1 : (a > GEOMETRY_EPS ? 1 : 0)); }",
            "constexpr inline int sgn(const int a) { return (a < 0 ? -1 : (a > 0 ? 1 : 0)); }",
            "",
            "// 2\u6b21\u5143\u5ea7\u6a19\u30af\u30e9\u30b9",
            "// T = int,long double\u306a\u3069",
            "template <typename T>",
            "struct Point {",
            "    T x, y;",
            "    constexpr inline Point(T x = 0, T y = 0) : x(x), y(y) {}",
            "",
            "    // unary operator: +,-",
            "    constexpr inline Point operator+() const { return *this; }",
            "    constexpr inline Point operator-() const { return Point(-x, -y); }",
            "",
            "    // +=,-=,*=,/=",
            "    constexpr inline Point &operator+=(const Point &q) {",
            "        x += q.x;",
            "        y += q.y;",
            "        return *this;",
            "    }",
            "    constexpr inline Point &operator-=(const Point &q) {",
            "        x -= q.x;",
            "        y -= q.y;",
            "        return *this;",
            "    }",
            "    template <typename U>",
            "    constexpr inline Point &operator*=(U a) {",
            "        x *= a;",
            "        y *= a;",
            "        return *this;",
            "    }",
            "    template <typename U>",
            "    constexpr inline Point &operator/=(U a) {",
            "        x /= a;",
            "        y /= a;",
            "        return *this;",
            "    }",
            "",
            "    // +,-,*,/",
            "    constexpr inline Point operator+(const Point &q) const { return Point(*this) += q; }",
            "    constexpr inline Point operator-(const Point &q) const { return Point(*this) -= q; }",
            "    template <typename U>",
            "    constexpr inline Point operator*(const U &a) const { return Point(*this) *= a; }",
            "    template <typename U>",
            "    constexpr inline Point operator/(const U &a) const { return Point(*this) /= a; }",
            "",
            "    // <,> \u306e\u6bd4\u8f03\u306f\u8f9e\u66f8\u9806\u306e\u6bd4\u8f03, \u3064\u307e\u308ax,y\u306e\u9806\u306b\u5927\u304d\u3044\u65b9\u3092\u78ba\u8a8d\u3059\u308b.",
            "    inline bool operator<(const Point &q) const { return (sgn(x - q.x) != 0 ? sgn(x - q.x) < 0 : sgn(y - q.y) < 0); }",
            "    inline bool operator>(const Point &q) const { return (sgn(x - q.x) != 0 ? sgn(x - q.x) > 0 : sgn(y - q.y) > 0); }",
            "    inline bool operator==(const Point &q) const { return (sgn(x - q.x) == 0 && sgn(y - q.y) == 0); }",
            "",
            "    friend ostream &operator<<(ostream &os, const Point &p) { return os << p.x << ' ' << p.y; }",
            "    friend istream &operator>>(istream &is, Point &p) { return is >> p.x >> p.y; }",
            "};",
            "",
            "// *,/",
            "template <typename T, typename U>",
            "inline Point<T> operator*(const U &s, const Point<T> &p) { return {s * p.x, s * p.y}; }",
            "template <typename T, typename U>",
            "inline Point<T> operator/(const U &s, const Point<T> &p) { return {p.x / s, p.y / s}; }",
            "",
            "// dot",
            "// p,q\u306e\u5185\u7a4d\u3092\u8a08\u7b97\u3059\u308b.",
            "template <typename T>",
            "constexpr inline T dot(const Point<T> &p, const Point<T> &q) { return p.x * q.x + p.y * q.y; }",
            "",
            "// cross",
            "// p,q\u306e\u5916\u7a4d\u3092\u8a08\u7b97\u3059\u308b",
            "template <typename T>",
            "constexpr inline T cross(const Point<T> &p, const Point<T> &q) { return p.x * q.y - q.x * p.y; }",
            "",
            "// length2",
            "// \u30d9\u30af\u30c8\u30ebp\u306e\u9577\u3055(\u539f\u70b9\u304b\u3089\u306e\u8ddd\u96e2)\u306e2\u4e57\u3092\u6c42\u3081\u308b.",
            "template <typename T>",
            "constexpr inline T length2(const Point<T> &p) { return dot(p, p); }",
            "",
            "// length",
            "// \u30d9\u30af\u30c8\u30ebp\u306e\u9577\u3055(\u539f\u70b9\u304b\u3089\u306e\u8ddd\u96e2)\u3092\u6c42\u3081\u308b.",
            "template <typename T>",
            "inline long double length(const Point<T> &p) { return sqrt((long double)length2(p)); }",
            "",
            "// dist",
            "// \u70b9p\u3068\u70b9q\u306e\u9593\u306e\u8ddd\u96e2\u3092\u6c42\u3081\u308b.",
            "template <typename T>",
            "inline long double dist(const Point<T> &p, const Point<T> &q) { return length(p - q); }",
            "",
            "// sgn_area",
            "// p,q,r\u304c\u3064\u304f\u308b\u4e09\u89d2\u5f62\u306e\u7b26\u53f7\u4ed8\u304d\u9762\u7a4d",
            "template <typename T>",
            "constexpr inline long double sgn_area(const Point<T> &p, const Point<T> &q, const Point<T> &r) { return (long double)cross(q - p, r - p) / 2.0; }",
            "",
            "// area",
            "// p,q,r\u304c\u3064\u304f\u308b\u4e09\u89d2\u5f62\u306e\u9762\u7a4d",
            "template <typename T>",
            "constexpr inline long double area(const Point<T> &p, const Point<T> &q, const Point<T> &r) { return abs(sgn_area(p, q, r)); }",
            "",
            "// normalize",
            "// \u70b9p\u3092\u9577\u30551\u306b\u6b63\u898f\u5316\u3057\u305f\u70b9\u3092\u8fd4\u3059.",
            "template <typename T>",
            "inline Point<long double> normalize(const Point<T> &p) { return (Point<long double>)p / length(p); }",
            "",
            "// rotation",
            "// \u70b9p\u3092\u53cd\u6642\u8a08\u56de\u308a\u306barg\u3060\u3051\u56de\u8ee2\u3055\u305b\u305f\u70b9\u3092\u8fd4\u3059. (arg\u306frad\u3067\u6e2c\u308b)",
            "template <typename T>",
            "inline Point<long double> rotation(const Point<T> &p, double arg) { return Point(cos(arg) * p.x - sin(arg) * p.y, sin(arg) * p.x + cos(arg) * p.y); }",
            "",
            "// angle",
            "// \u70b9p\u306ex\u8ef8\u306e\u6b63\u306e\u65b9\u5411\u304b\u3089\u53cd\u6642\u8a08\u56de\u308a\u306b\u6e2c\u3063\u305f\u89d2\u5ea6\u3092[-pi,pi]\u3067\u8fd4\u3059.",
            "template <typename T>",
            "inline long double angle(const Point<T> &p) { return atan2(p.y, p.x); }",
            "",
            "// rot90",
            "// \u70b9p\u3092\u53cd\u6642\u8a08\u56de\u308a\u306b90\u5ea6\u56de\u8ee2",
            "template <typename T>",
            "constexpr inline Point<T> rot90(const Point<T> &p) { return Point(-p.y, p.x); }",
            "",
            "// iSP",
            "// \u7570\u306a\u308b3\u70b9a,b,c\u306e\u4f4d\u7f6e\u95a2\u4fc2\u3092\u8fd4\u3059.",
            "template <typename T>",
            "int iSP(const Point<T> &a, const Point<T> &b, const Point<T> &c) {",
            "    if (sgn(cross(c - b, a - b)) > 0) return 1;  // ab bc __/: +1",
            "    if (sgn(cross(c - b, a - b)) < 0) return -1; // ab bc --\\: -1",
            "    if (sgn(dot(a - b, c - b)) < 0) return 2;    // abc   ---: +2",
            "    if (sgn(dot(a - c, b - c)) < 0) return -2;   // acb   ---: -2",
            "    return 0;                                    // bac   ---:  0",
            "}",
            "",
            "// example:",
            "// using P = Point<int>;",
            "// using P = Point<long double>;",
            "",
            "// convex_hull",
            "// \u70b9\u96c6\u5408points\u306e\u51f8\u5305\u3092\u6c42\u3081\u308b.",
            "// \u6c42\u3081\u305f\u51f8\u5305\u306f\u6700\u3082\u5de6\u306b\u3042\u308b\u3082\u306e\u306e\u3046\u3061\u6700\u3082\u4e0b\u306b\u3042\u308b\u3082\u306e\u304b\u3089\u9806\u306b\u53cd\u6642\u8a08\u56de\u308a\u306b\u4e26\u3093\u3067\u3044\u308b.",
            "template <typename T>",
            "vector<Point<T>> convex_hull(vector<Point<T>> points) {",
            "    sort(points.begin(), points.end());",
            "    int n = (int)points.size(), k = 0;",
            "    vector<Point<T>> convex(2 * n);",
            "    for (int i = 0; i < n; i++) {",
            "        while (k > 1 && iSP(convex[k - 2], convex[k - 1], points[i]) == -1)",
            "            k--;",
            "        convex[k++] = points[i];",
            "    }",
            "    for (int i = n - 2, t = k; i >= 0; i--) {",
            "        while (k > t && iSP(convex[k - 2], convex[k - 1], points[i]) == -1)",
            "            k--;",
            "        convex[k++] = points[i];",
            "    }",
            "    convex.resize(k - 1);",
            "    return convex;",
            "}",
            "",
            "// polygon_area",
            "// points\u306en\u70b9\u304b\u3089\u306a\u308b\u591a\u89d2\u5f62G\u306e\u9762\u7a4d\u3092\u6c42\u3081\u308b.",
            "// G\u306fpoints[i],points[(i + 1)%n]\u306e2\u3064\u306e\u9802\u70b9\u3092\u7d50\u3076\u7dda\u5206\u3092",
            "// \u8fba\u3068\u3059\u308b\u591a\u89d2\u5f62\u3067\u3042\u308b.",
            "template <typename T>",
            "long double polygon_area(const vector<Point<T>> &points) {",
            "    int n           = (int)points.size();",
            "    long double ret = 0;",
            "    for (int i = 0; i + 2 < n; i++)",
            "        ret += sgn_area(points[0], points[i + 1], points[i + 2]);",
            "    return abs(ret);",
            "}",
            "",
            "// diameter",
            "// \u51f8\u591a\u89d2\u5f62convex\u306e\u76f4\u5f84(\u6700\u9060\u70b9\u5bfe\u306e\u8ddd\u96e2)\u3092\u6c42\u3081\u308b.",
            "template <typename T>",
            "long double diameter(const vector<Point<T>> &convex) {",
            "    int n = (int)convex.size();",
            "    if (n == 2)",
            "        return dist(convex[0], convex[1]);",
            "",
            "    int i = 0, j = 0;",
            "    for (int k = 0; k < n; k++) {",
            "        if (convex[i] < convex[k]) i = k;",
            "        if (convex[j] > convex[k]) j = k;",
            "    }",
            "",
            "    long double ret = 0;",
            "    int si = i, sj = j;",
            "    while (i != sj || j != si) {",
            "        ret = max(ret, dist(convex[i], convex[j]));",
            "        if (sgn(cross(convex[(i + 1) % n] - convex[i], convex[(j + 1) % n] - convex[j])) < 0)",
            "            i = (i + 1) % n;",
            "        else",
            "            j = (j + 1) % n;",
            "    }",
            "    return ret;",
            "}"
        ],
        "description": ""
    },
    "./math/mod_comb.cpp": {
        "prefix": "snp mod_comb",
        "body": [
            "",
            "template <int MOD>",
            "struct ModInt {",
            "  public:",
            "    long long x;",
            "    ModInt(long long x = 0) : x((x % MOD + MOD) % MOD) {}",
            "    constexpr ModInt &operator+=(const ModInt a) noexcept {",
            "        if ((x += a.x) >= MOD) x -= MOD;",
            "        return *this;",
            "    }",
            "    constexpr ModInt &operator-=(const ModInt a) noexcept {",
            "        if ((x += MOD - a.x) >= MOD) x -= MOD;",
            "        return *this;",
            "    }",
            "    constexpr ModInt &operator*=(const ModInt a) noexcept {",
            "        (x *= a.x) %= MOD;",
            "        return *this;",
            "    }",
            "    constexpr ModInt &operator/=(const ModInt a) noexcept { return *this *= a.inverse(); }",
            "",
            "    constexpr ModInt operator+(const ModInt a) const noexcept { return ModInt(*this) += a.x; }",
            "    constexpr ModInt operator-(const ModInt a) const noexcept { return ModInt(*this) -= a.x; }",
            "    constexpr ModInt operator*(const ModInt a) const noexcept { return ModInt(*this) *= a.x; }",
            "    constexpr ModInt operator/(const ModInt a) const noexcept { return ModInt(*this) /= a.x; }",
            "",
            "    friend constexpr std::ostream &operator<<(std::ostream &os, const ModInt<MOD> a) noexcept { return os << a.x; }",
            "    friend constexpr std::istream &operator>>(std::istream &is, ModInt<MOD> &a) noexcept { return is >> a.x; }",
            "",
            "    ModInt inverse() const noexcept { // x ^ (-1)",
            "        long long a = x, b = MOD, p = 1, q = 0;",
            "        while (b) {",
            "            long long d = a / b;",
            "            a -= d * b;",
            "            swap(a, b);",
            "            p -= d * q;",
            "            swap(p, q);",
            "        }",
            "        return ModInt(p);",
            "    }",
            "    ModInt pow(long long N) const noexcept { // x ^ N",
            "        ModInt a = 1;",
            "        ModInt y = this->x;",
            "        while (N) {",
            "            if (N & 1) a *= y;",
            "            y *= y;",
            "            N >>= 1;",
            "        }",
            "        return a;",
            "    }",
            "};",
            "",
            "template <typename U, int MOD>",
            "inline ModInt<MOD> operator*(const U &c, const ModInt<MOD> &a) { return {c * a.x}; }",
            "",
            "using mint = ModInt<998244353>;",
            "",
            "// Combination",
            "// mod MOD\u3067\u968e\u4e57\u3092\u8a08\u7b97\u3057\u3066\u304a\u304f\u3053\u3068\u3067comb(n,k)\u306a\u3069\u3092O(1)",
            "// \u3067\u8a08\u7b97\u3059\u308b. MOD\u306fconst\u306a\u7d20\u6570",
            "template <const int MOD>",
            "struct Combination {",
            "    using mint = ModInt<MOD>;",
            "    int n;",
            "    vector<mint> fact, ifact, invs;",
            "",
            "    Combination(int n) : n(n) {",
            "        fact.resize(n + 1);",
            "        ifact.resize(n + 1);",
            "        fact[0] = fact[1] = 1;",
            "        ifact[0] = ifact[1] = 1;",
            "        for (int i = 2; i <= n; ++i) {",
            "            fact[i] = fact[i - 1] * i;",
            "        }",
            "        ifact[n] = fact[n].inverse();",
            "        for (int i = n; i >= 1; --i) {",
            "            ifact[i - 1] = ifact[i] * i;",
            "        }",
            "    }",
            "",
            "    // invs_build",
            "    // ax = 1 mod MOD\u3092\u307f\u305f\u3059x\u3092a=1,...,n\u306b\u3064\u3044\u3066\u8a08\u7b97\u3059\u308b.",
            "    // \u8a08\u7b97\u91cf: O(n)",
            "    void invs_build() {",
            "        invs.resize(n + 1);",
            "        invs[1] = 1;",
            "        for (int i = 2; i <= n; ++i)",
            "            invs[i] = fact[i] * ifact[i - 1];",
            "    }",
            "",
            "    // (n,k)",
            "    // 0 <= k <= n\u306a\u3089 nCk \u3092\u8fd4\u3057, \u305d\u3046\u3067\u306a\u3044\u306a\u30890\u3092\u8fd4\u3059.",
            "    // \u5236\u7d04: k,n\u6574\u6570",
            "    mint operator()(int n, int k) {",
            "        if (k < 0 || k > n) return 0;",
            "        return fact[n] * ifact[k] * ifact[n - k];",
            "    }",
            "",
            "    // npk",
            "    // 0 <= k <= n\u306a\u3089 nPk \u3092\u8fd4\u3057, \u305d\u3046\u3067\u306a\u3044\u306a\u30890\u3092\u8fd4\u3059.",
            "    // \u5236\u7d04: k,n\u6574\u6570",
            "    mint npk(int n, int k) {",
            "        if (k < 0 || k > n) return 0;",
            "        return fact[n] * ifact[n - k];",
            "    }",
            "};",
            "",
            "// nck_nbig",
            "// n\u304c\u5927\u304d\u3044\u6642\u306bnCk\u3092\u8a08\u7b97\u3059\u308b",
            "// \u8a08\u7b97\u91cf: O(k)",
            "template <const int MOD>",
            "ModInt<MOD> nck_nbig(long long n, int k) {",
            "    using mint = ModInt<MOD>;",
            "    mint ans   = 1;",
            "    for (int i = 0; i < k; ++i)",
            "        ans *= mint(n - i);",
            "    for (int i = 1; i < k + 1; ++i)",
            "        ans *= mint(i).inverse();",
            "    return ans;",
            "}",
            "",
            "// modpow",
            "// x^y mod m\u3092\u8a08\u7b97\u3059\u308b",
            "// \u8a08\u7b97\u91cf: O(logy)",
            "long long modpow(long long x, long long y, long long m) {",
            "    long long ans = 1, tmp = x;",
            "    while (y > 0) {",
            "        if (y & 1) {",
            "            ans = (ans * tmp) % m;",
            "        }",
            "        y >>= 1;",
            "        tmp = (tmp * tmp) % m;",
            "    }",
            "    return ans;",
            "}"
        ],
        "description": ""
    },
    "./math/mint.cpp": {
        "prefix": "snp mint",
        "body": [
            "",
            "template <int MOD>",
            "struct ModInt {",
            "  public:",
            "    long long x;",
            "    ModInt(long long x = 0) : x((x % MOD + MOD) % MOD) {}",
            "    constexpr ModInt &operator+=(const ModInt a) noexcept {",
            "        if ((x += a.x) >= MOD) x -= MOD;",
            "        return *this;",
            "    }",
            "    constexpr ModInt &operator-=(const ModInt a) noexcept {",
            "        if ((x += MOD - a.x) >= MOD) x -= MOD;",
            "        return *this;",
            "    }",
            "    constexpr ModInt &operator*=(const ModInt a) noexcept {",
            "        (x *= a.x) %= MOD;",
            "        return *this;",
            "    }",
            "    constexpr ModInt &operator/=(const ModInt a) noexcept { return *this *= a.inverse(); }",
            "",
            "    constexpr ModInt operator+(const ModInt a) const noexcept { return ModInt(*this) += a.x; }",
            "    constexpr ModInt operator-(const ModInt a) const noexcept { return ModInt(*this) -= a.x; }",
            "    constexpr ModInt operator*(const ModInt a) const noexcept { return ModInt(*this) *= a.x; }",
            "    constexpr ModInt operator/(const ModInt a) const noexcept { return ModInt(*this) /= a.x; }",
            "",
            "    friend constexpr std::ostream &operator<<(std::ostream &os, const ModInt<MOD> a) noexcept { return os << a.x; }",
            "    friend constexpr std::istream &operator>>(std::istream &is, ModInt<MOD> &a) noexcept { return is >> a.x; }",
            "",
            "    ModInt inverse() const noexcept { // x ^ (-1)",
            "        long long a = x, b = MOD, p = 1, q = 0;",
            "        while (b) {",
            "            long long d = a / b;",
            "            a -= d * b;",
            "            swap(a, b);",
            "            p -= d * q;",
            "            swap(p, q);",
            "        }",
            "        return ModInt(p);",
            "    }",
            "    ModInt pow(long long N) const noexcept { // x ^ N",
            "        ModInt a = 1;",
            "        ModInt y = this->x;",
            "        while (N) {",
            "            if (N & 1) a *= y;",
            "            y *= y;",
            "            N >>= 1;",
            "        }",
            "        return a;",
            "    }",
            "};",
            "",
            "template <typename U, int MOD>",
            "inline ModInt<MOD> operator*(const U &c, const ModInt<MOD> &a) { return {c * a.x}; }",
            "",
            "using mint = ModInt<998244353>;"
        ],
        "description": ""
    },
    "./math/euclid.cpp": {
        "prefix": "snp euclid",
        "body": [
            "",
            "// gcd",
            "// \u975e\u8ca0\u6574\u6570a,b\u306e\u6700\u5927\u516c\u7d04\u6570\u3092\u6c42\u3081\u308b.",
            "// \u5236\u7d04: a,b >= 0",
            "// \u8a08\u7b97\u91cf: O(logmax(a,b))",
            "template <typename T>",
            "T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }",
            "",
            "// lcm",
            "// \u975e\u8ca0\u6574\u6570a,b\u306e\u6700\u5c0f\u516c\u500d\u6570\u3092\u6c42\u3081\u308b.",
            "// \u5236\u7d04: a,b >= 0",
            "// \u8a08\u7b97\u91cf: O(logmax(a,b))",
            "template <typename T>",
            "T lcm(T a, T b) { return a / gcd(a, b) * b; }",
            "",
            "// ext_gcd",
            "// \u62e1\u5f35Euclid\u306e\u4e92\u9664\u6cd5\u3067\u975e\u8ca0\u6574\u6570a,b\u306b\u5bfe\u3057\u3066ax + by = gcd(a,b)\u3092\u6e80\u305f\u3059\u6574\u6570x,y\u3092\u6c42\u3081\u308b.",
            "// \u51fa\u529b\u3055\u308c\u308b\u5024\u306f xy != 0 \u306a\u3089\u3070 |x| <= b,|y| <= a \u3092\u6e80\u305f\u3059.",
            "// \u5236\u7d04: a,b >= 0",
            "// \u8a08\u7b97\u91cf: O(logmax(a,b))",
            "template <typename T>",
            "pair<T, T> ext_gcd(T a, T b) {",
            "    if (b == 0) {",
            "        return make_pair(1, 0);",
            "    }",
            "    auto [x, y] = ext_gcd(b, a % b);",
            "    return make_pair(y, x - a / b * y);",
            "}"
        ],
        "description": ""
    },
    "./math/point.cpp": {
        "prefix": "snp point",
        "body": [
            "",
            "constexpr long double GEOMETRY_EPS = 1e-8;",
            "",
            "// sgn",
            "// a > 0\u306a\u30891, a = 0\u306a\u30890,a < 0\u306a\u3089-1\u3092\u8fd4\u3059.",
            "constexpr inline int sgn(const long double a) { return (a < -GEOMETRY_EPS ? -1 : (a > GEOMETRY_EPS ? 1 : 0)); }",
            "constexpr inline int sgn(const int a) { return (a < 0 ? -1 : (a > 0 ? 1 : 0)); }",
            "",
            "// 2\u6b21\u5143\u5ea7\u6a19\u30af\u30e9\u30b9",
            "// T = int,long double\u306a\u3069",
            "template <typename T>",
            "struct Point {",
            "    T x, y;",
            "    constexpr inline Point(T x = 0, T y = 0) : x(x), y(y) {}",
            "",
            "    // unary operator: +,-",
            "    constexpr inline Point operator+() const { return *this; }",
            "    constexpr inline Point operator-() const { return Point(-x, -y); }",
            "",
            "    // +=,-=,*=,/=",
            "    constexpr inline Point &operator+=(const Point &q) {",
            "        x += q.x;",
            "        y += q.y;",
            "        return *this;",
            "    }",
            "    constexpr inline Point &operator-=(const Point &q) {",
            "        x -= q.x;",
            "        y -= q.y;",
            "        return *this;",
            "    }",
            "    template <typename U>",
            "    constexpr inline Point &operator*=(U a) {",
            "        x *= a;",
            "        y *= a;",
            "        return *this;",
            "    }",
            "    template <typename U>",
            "    constexpr inline Point &operator/=(U a) {",
            "        x /= a;",
            "        y /= a;",
            "        return *this;",
            "    }",
            "",
            "    // +,-,*,/",
            "    constexpr inline Point operator+(const Point &q) const { return Point(*this) += q; }",
            "    constexpr inline Point operator-(const Point &q) const { return Point(*this) -= q; }",
            "    template <typename U>",
            "    constexpr inline Point operator*(const U &a) const { return Point(*this) *= a; }",
            "    template <typename U>",
            "    constexpr inline Point operator/(const U &a) const { return Point(*this) /= a; }",
            "",
            "    // <,> \u306e\u6bd4\u8f03\u306f\u8f9e\u66f8\u9806\u306e\u6bd4\u8f03, \u3064\u307e\u308ax,y\u306e\u9806\u306b\u5927\u304d\u3044\u65b9\u3092\u78ba\u8a8d\u3059\u308b.",
            "    inline bool operator<(const Point &q) const { return (sgn(x - q.x) != 0 ? sgn(x - q.x) < 0 : sgn(y - q.y) < 0); }",
            "    inline bool operator>(const Point &q) const { return (sgn(x - q.x) != 0 ? sgn(x - q.x) > 0 : sgn(y - q.y) > 0); }",
            "    inline bool operator==(const Point &q) const { return (sgn(x - q.x) == 0 && sgn(y - q.y) == 0); }",
            "",
            "    friend ostream &operator<<(ostream &os, const Point &p) { return os << p.x << ' ' << p.y; }",
            "    friend istream &operator>>(istream &is, Point &p) { return is >> p.x >> p.y; }",
            "};",
            "",
            "// *,/",
            "template <typename T, typename U>",
            "inline Point<T> operator*(const U &s, const Point<T> &p) { return {s * p.x, s * p.y}; }",
            "template <typename T, typename U>",
            "inline Point<T> operator/(const U &s, const Point<T> &p) { return {p.x / s, p.y / s}; }",
            "",
            "// dot",
            "// p,q\u306e\u5185\u7a4d\u3092\u8a08\u7b97\u3059\u308b.",
            "template <typename T>",
            "constexpr inline T dot(const Point<T> &p, const Point<T> &q) { return p.x * q.x + p.y * q.y; }",
            "",
            "// cross",
            "// p,q\u306e\u5916\u7a4d\u3092\u8a08\u7b97\u3059\u308b",
            "template <typename T>",
            "constexpr inline T cross(const Point<T> &p, const Point<T> &q) { return p.x * q.y - q.x * p.y; }",
            "",
            "// length2",
            "// \u30d9\u30af\u30c8\u30ebp\u306e\u9577\u3055(\u539f\u70b9\u304b\u3089\u306e\u8ddd\u96e2)\u306e2\u4e57\u3092\u6c42\u3081\u308b.",
            "template <typename T>",
            "constexpr inline T length2(const Point<T> &p) { return dot(p, p); }",
            "",
            "// length",
            "// \u30d9\u30af\u30c8\u30ebp\u306e\u9577\u3055(\u539f\u70b9\u304b\u3089\u306e\u8ddd\u96e2)\u3092\u6c42\u3081\u308b.",
            "template <typename T>",
            "inline long double length(const Point<T> &p) { return sqrt((long double)length2(p)); }",
            "",
            "// dist",
            "// \u70b9p\u3068\u70b9q\u306e\u9593\u306e\u8ddd\u96e2\u3092\u6c42\u3081\u308b.",
            "template <typename T>",
            "inline long double dist(const Point<T> &p, const Point<T> &q) { return length(p - q); }",
            "",
            "// sgn_area",
            "// p,q,r\u304c\u3064\u304f\u308b\u4e09\u89d2\u5f62\u306e\u7b26\u53f7\u4ed8\u304d\u9762\u7a4d",
            "template <typename T>",
            "constexpr inline long double sgn_area(const Point<T> &p, const Point<T> &q, const Point<T> &r) { return (long double)cross(q - p, r - p) / 2.0; }",
            "",
            "// area",
            "// p,q,r\u304c\u3064\u304f\u308b\u4e09\u89d2\u5f62\u306e\u9762\u7a4d",
            "template <typename T>",
            "constexpr inline long double area(const Point<T> &p, const Point<T> &q, const Point<T> &r) { return abs(sgn_area(p, q, r)); }",
            "",
            "// normalize",
            "// \u70b9p\u3092\u9577\u30551\u306b\u6b63\u898f\u5316\u3057\u305f\u70b9\u3092\u8fd4\u3059.",
            "template <typename T>",
            "inline Point<long double> normalize(const Point<T> &p) { return (Point<long double>)p / length(p); }",
            "",
            "// rotation",
            "// \u70b9p\u3092\u53cd\u6642\u8a08\u56de\u308a\u306barg\u3060\u3051\u56de\u8ee2\u3055\u305b\u305f\u70b9\u3092\u8fd4\u3059. (arg\u306frad\u3067\u6e2c\u308b)",
            "template <typename T>",
            "inline Point<long double> rotation(const Point<T> &p, double arg) { return Point(cos(arg) * p.x - sin(arg) * p.y, sin(arg) * p.x + cos(arg) * p.y); }",
            "",
            "// angle",
            "// \u70b9p\u306ex\u8ef8\u306e\u6b63\u306e\u65b9\u5411\u304b\u3089\u53cd\u6642\u8a08\u56de\u308a\u306b\u6e2c\u3063\u305f\u89d2\u5ea6\u3092[-pi,pi]\u3067\u8fd4\u3059.",
            "template <typename T>",
            "inline long double angle(const Point<T> &p) { return atan2(p.y, p.x); }",
            "",
            "// rot90",
            "// \u70b9p\u3092\u53cd\u6642\u8a08\u56de\u308a\u306b90\u5ea6\u56de\u8ee2",
            "template <typename T>",
            "constexpr inline Point<T> rot90(const Point<T> &p) { return Point(-p.y, p.x); }",
            "",
            "// iSP",
            "// \u7570\u306a\u308b3\u70b9a,b,c\u306e\u4f4d\u7f6e\u95a2\u4fc2\u3092\u8fd4\u3059.",
            "template <typename T>",
            "int iSP(const Point<T> &a, const Point<T> &b, const Point<T> &c) {",
            "    if (sgn(cross(c - b, a - b)) > 0) return 1;  // ab bc __/: +1",
            "    if (sgn(cross(c - b, a - b)) < 0) return -1; // ab bc --\\: -1",
            "    if (sgn(dot(a - b, c - b)) < 0) return 2;    // abc   ---: +2",
            "    if (sgn(dot(a - c, b - c)) < 0) return -2;   // acb   ---: -2",
            "    return 0;                                    // bac   ---:  0",
            "}",
            "",
            "// example:",
            "// using P = Point<int>;",
            "// using P = Point<long double>;"
        ],
        "description": ""
    },
    "./math/stirling_number2.cpp": {
        "prefix": "snp stirling_number2",
        "body": [
            "",
            "// StirlingNumber2",
            "// n\u500b\u306e\u533a\u5225\u3067\u304d\u308b\u3082\u306e\u3092k\u500b\u306e\u533a\u5225\u3067\u304d\u306a\u3044\u7bb1\u306b1\u500b\u4ee5\u4e0a\u306b\u5206\u5272\u3059\u308b\u65b9\u6cd5\u304c\u4f55\u901a\u308a\u3042\u308b\u304b\u6c42\u3081\u308b.",
            "// \u3053\u308c\u3092S(n,k)\u3068\u3059\u308b. \u7b2c\u4e8c\u7a2e\u30b9\u30bf\u30fc\u30ea\u30f3\u30b0\u6570",
            "template <typename T>",
            "struct StirlingNumber2 {",
            "    int n, k;",
            "    vector<vector<T>> dp;",
            "",
            "    StirlingNumber2(int n, int k) : n(n), k(k) {",
            "        dp.assign(n + 1, vector<T>(k + 1, T(0)));",
            "    }",
            "",
            "    // solve",
            "    // S(i,j) (0 <= i <= n, 0 <= j <= k)\u3092\u6c42\u3081\u308b.",
            "    // \u8a08\u7b97\u91cf: O(nk)",
            "    T solve() {",
            "        dp[0][0] = T(1);",
            "        for (int i = 1; i <= n; i++) {",
            "            for (int j = 0; j <= k; j++) {",
            "                dp[i][j] = T(j) * dp[i - 1][j];",
            "                if (j > 0) dp[i][j] += dp[i - 1][j - 1];",
            "            }",
            "        }",
            "        return dp[n][k];",
            "    }",
            "",
            "    // S(i,j)\u3092\u8fd4\u3059.",
            "    // \u5236\u7d04: 0 <= i <= n, 0 <= j <= k",
            "    T operator()(int i, int j) {",
            "        return dp[i][j];",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./math/line.cpp": {
        "prefix": "snp line",
        "body": [
            "",
            "",
            "constexpr long double GEOMETRY_EPS = 1e-8;",
            "",
            "// sgn",
            "// a > 0\u306a\u30891, a = 0\u306a\u30890,a < 0\u306a\u3089-1\u3092\u8fd4\u3059.",
            "constexpr inline int sgn(const long double a) { return (a < -GEOMETRY_EPS ? -1 : (a > GEOMETRY_EPS ? 1 : 0)); }",
            "constexpr inline int sgn(const int a) { return (a < 0 ? -1 : (a > 0 ? 1 : 0)); }",
            "",
            "// 2\u6b21\u5143\u5ea7\u6a19\u30af\u30e9\u30b9",
            "// T = int,long double\u306a\u3069",
            "template <typename T>",
            "struct Point {",
            "    T x, y;",
            "    constexpr inline Point(T x = 0, T y = 0) : x(x), y(y) {}",
            "",
            "    // unary operator: +,-",
            "    constexpr inline Point operator+() const { return *this; }",
            "    constexpr inline Point operator-() const { return Point(-x, -y); }",
            "",
            "    // +=,-=,*=,/=",
            "    constexpr inline Point &operator+=(const Point &q) {",
            "        x += q.x;",
            "        y += q.y;",
            "        return *this;",
            "    }",
            "    constexpr inline Point &operator-=(const Point &q) {",
            "        x -= q.x;",
            "        y -= q.y;",
            "        return *this;",
            "    }",
            "    template <typename U>",
            "    constexpr inline Point &operator*=(U a) {",
            "        x *= a;",
            "        y *= a;",
            "        return *this;",
            "    }",
            "    template <typename U>",
            "    constexpr inline Point &operator/=(U a) {",
            "        x /= a;",
            "        y /= a;",
            "        return *this;",
            "    }",
            "",
            "    // +,-,*,/",
            "    constexpr inline Point operator+(const Point &q) const { return Point(*this) += q; }",
            "    constexpr inline Point operator-(const Point &q) const { return Point(*this) -= q; }",
            "    template <typename U>",
            "    constexpr inline Point operator*(const U &a) const { return Point(*this) *= a; }",
            "    template <typename U>",
            "    constexpr inline Point operator/(const U &a) const { return Point(*this) /= a; }",
            "",
            "    // <,> \u306e\u6bd4\u8f03\u306f\u8f9e\u66f8\u9806\u306e\u6bd4\u8f03, \u3064\u307e\u308ax,y\u306e\u9806\u306b\u5927\u304d\u3044\u65b9\u3092\u78ba\u8a8d\u3059\u308b.",
            "    inline bool operator<(const Point &q) const { return (sgn(x - q.x) != 0 ? sgn(x - q.x) < 0 : sgn(y - q.y) < 0); }",
            "    inline bool operator>(const Point &q) const { return (sgn(x - q.x) != 0 ? sgn(x - q.x) > 0 : sgn(y - q.y) > 0); }",
            "    inline bool operator==(const Point &q) const { return (sgn(x - q.x) == 0 && sgn(y - q.y) == 0); }",
            "",
            "    friend ostream &operator<<(ostream &os, const Point &p) { return os << p.x << ' ' << p.y; }",
            "    friend istream &operator>>(istream &is, Point &p) { return is >> p.x >> p.y; }",
            "};",
            "",
            "// *,/",
            "template <typename T, typename U>",
            "inline Point<T> operator*(const U &s, const Point<T> &p) { return {s * p.x, s * p.y}; }",
            "template <typename T, typename U>",
            "inline Point<T> operator/(const U &s, const Point<T> &p) { return {p.x / s, p.y / s}; }",
            "",
            "// dot",
            "// p,q\u306e\u5185\u7a4d\u3092\u8a08\u7b97\u3059\u308b.",
            "template <typename T>",
            "constexpr inline T dot(const Point<T> &p, const Point<T> &q) { return p.x * q.x + p.y * q.y; }",
            "",
            "// cross",
            "// p,q\u306e\u5916\u7a4d\u3092\u8a08\u7b97\u3059\u308b",
            "template <typename T>",
            "constexpr inline T cross(const Point<T> &p, const Point<T> &q) { return p.x * q.y - q.x * p.y; }",
            "",
            "// length2",
            "// \u30d9\u30af\u30c8\u30ebp\u306e\u9577\u3055(\u539f\u70b9\u304b\u3089\u306e\u8ddd\u96e2)\u306e2\u4e57\u3092\u6c42\u3081\u308b.",
            "template <typename T>",
            "constexpr inline T length2(const Point<T> &p) { return dot(p, p); }",
            "",
            "// length",
            "// \u30d9\u30af\u30c8\u30ebp\u306e\u9577\u3055(\u539f\u70b9\u304b\u3089\u306e\u8ddd\u96e2)\u3092\u6c42\u3081\u308b.",
            "template <typename T>",
            "inline long double length(const Point<T> &p) { return sqrt((long double)length2(p)); }",
            "",
            "// dist",
            "// \u70b9p\u3068\u70b9q\u306e\u9593\u306e\u8ddd\u96e2\u3092\u6c42\u3081\u308b.",
            "template <typename T>",
            "inline long double dist(const Point<T> &p, const Point<T> &q) { return length(p - q); }",
            "",
            "// sgn_area",
            "// p,q,r\u304c\u3064\u304f\u308b\u4e09\u89d2\u5f62\u306e\u7b26\u53f7\u4ed8\u304d\u9762\u7a4d",
            "template <typename T>",
            "constexpr inline long double sgn_area(const Point<T> &p, const Point<T> &q, const Point<T> &r) { return (long double)cross(q - p, r - p) / 2.0; }",
            "",
            "// area",
            "// p,q,r\u304c\u3064\u304f\u308b\u4e09\u89d2\u5f62\u306e\u9762\u7a4d",
            "template <typename T>",
            "constexpr inline long double area(const Point<T> &p, const Point<T> &q, const Point<T> &r) { return abs(sgn_area(p, q, r)); }",
            "",
            "// normalize",
            "// \u70b9p\u3092\u9577\u30551\u306b\u6b63\u898f\u5316\u3057\u305f\u70b9\u3092\u8fd4\u3059.",
            "template <typename T>",
            "inline Point<long double> normalize(const Point<T> &p) { return (Point<long double>)p / length(p); }",
            "",
            "// rotation",
            "// \u70b9p\u3092\u53cd\u6642\u8a08\u56de\u308a\u306barg\u3060\u3051\u56de\u8ee2\u3055\u305b\u305f\u70b9\u3092\u8fd4\u3059. (arg\u306frad\u3067\u6e2c\u308b)",
            "template <typename T>",
            "inline Point<long double> rotation(const Point<T> &p, double arg) { return Point(cos(arg) * p.x - sin(arg) * p.y, sin(arg) * p.x + cos(arg) * p.y); }",
            "",
            "// angle",
            "// \u70b9p\u306ex\u8ef8\u306e\u6b63\u306e\u65b9\u5411\u304b\u3089\u53cd\u6642\u8a08\u56de\u308a\u306b\u6e2c\u3063\u305f\u89d2\u5ea6\u3092[-pi,pi]\u3067\u8fd4\u3059.",
            "template <typename T>",
            "inline long double angle(const Point<T> &p) { return atan2(p.y, p.x); }",
            "",
            "// rot90",
            "// \u70b9p\u3092\u53cd\u6642\u8a08\u56de\u308a\u306b90\u5ea6\u56de\u8ee2",
            "template <typename T>",
            "constexpr inline Point<T> rot90(const Point<T> &p) { return Point(-p.y, p.x); }",
            "",
            "// iSP",
            "// \u7570\u306a\u308b3\u70b9a,b,c\u306e\u4f4d\u7f6e\u95a2\u4fc2\u3092\u8fd4\u3059.",
            "template <typename T>",
            "int iSP(const Point<T> &a, const Point<T> &b, const Point<T> &c) {",
            "    if (sgn(cross(c - b, a - b)) > 0) return 1;  // ab bc __/: +1",
            "    if (sgn(cross(c - b, a - b)) < 0) return -1; // ab bc --\\: -1",
            "    if (sgn(dot(a - b, c - b)) < 0) return 2;    // abc   ---: +2",
            "    if (sgn(dot(a - c, b - c)) < 0) return -2;   // acb   ---: -2",
            "    return 0;                                    // bac   ---:  0",
            "}",
            "",
            "// example:",
            "// using P = Point<int>;",
            "// using P = Point<long double>;",
            "",
            "/* Line */",
            "",
            "constexpr long double GEOMETRY_INFTY = 1e9;",
            "",
            "// \u7121\u9650\u9060\u70b9",
            "template <typename T>",
            "constexpr Point<T> INFTY(GEOMETRY_INFTY, GEOMETRY_INFTY);",
            "",
            "// \u76f4\u7dda",
            "template <typename T>",
            "struct Line {",
            "    Point<T> begin, end;",
            "    Line() = default;",
            "    Line(const Point<T> &begin, const Point<T> &end) : begin(begin), end(end) {}",
            "",
            "    constexpr inline Point<T> vec() const { return end - begin; }",
            "    constexpr inline Point<T> countervec() const { return begin - end; }",
            "};",
            "",
            "// \u534a\u76f4\u7dda",
            "template <typename T>",
            "using Ray = Line<T>;",
            "",
            "// \u7dda\u5206",
            "template <typename T>",
            "using Segment = Line<T>;",
            "",
            "// ll_intersection",
            "// \u76f4\u7dda\u540c\u58eb\u306e\u4ea4\u70b9\u3092\u8fd4\u3059.",
            "template <typename T>",
            "Point<T> ll_intersection(const Line<T> &l1, const Line<T> &l2) {",
            "    if (sgn(cross(l1.vec(), l2.vec())) == 0) return INFTY<T>;                                      // parallel or partially matched",
            "    return l1.begin + l1.vec() * cross(l2.vec(), l2.begin - l1.begin) / cross(l2.vec(), l1.vec()); // Intersection",
            "}",
            "",
            "// ss_intersection",
            "// \u7dda\u5206\u540c\u58eb\u306e\u4ea4\u70b9\u3092\u6c42\u3081\u308b. (\u7dda\u5206\u304c\u4ea4\u308f\u308b\u304b\u3069\u3046\u304b, \u4ea4\u70b9)\u3092\u8fd4\u3059.",
            "template <typename T>",
            "pair<bool, Point<T>> ss_intersection(const Segment<T> &s1, const Segment<T> &s2) {",
            "    bool is_intersect = (iSP(s2.begin, s1.begin, s1.end) * iSP(s2.end, s1.begin, s1.end) <= 0 && iSP(s1.begin, s2.begin, s2.end) * iSP(s1.end, s2.begin, s2.end) <= 0);",
            "    return {is_intersect, ll_intersection(s1, s2)};",
            "}",
            "",
            "// sr_intersection",
            "// \u7dda\u5206\u3068\u534a\u76f4\u7dda\u306e\u4ea4\u70b9\u3092\u6c42\u3081\u308b.",
            "template <typename T>",
            "pair<bool, Point<T>> sr_intersection(const Segment<T> &s, const Ray<T> &r) {",
            "    Point ret = ll_intersection(s, r);",
            "    if (ret == INFTY<T>) return {false, ret};",
            "    Point sv1 = s.begin - ret, sv2 = s.end - ret;",
            "    Point rv1 = ret - r.begin, rv2 = r.end - r.begin;",
            "    if (sgn(dot(sv1, sv2)) <= 0 && sgn(dot(rv1, rv2)) > 0) return {true, ret};",
            "    return {false, ret};",
            "}",
            "",
            "// ison",
            "// \u70b9p\u304c\u7dda\u5206s\u4e0a\u306e\u70b9\u304b\u3069\u3046\u304b\u3092\u5224\u5b9a\u3059\u308b.",
            "template <typename T>",
            "constexpr inline bool ison(const Point<T> &p, const Segment<T> &s) { return iSP(p, s.begin, s.end) == 0; }",
            "",
            "// pl_distance",
            "// \u70b9p\u3068\u76f4\u7ddal\u306e\u8ddd\u96e2\u3092\u6c42\u3081\u308b.",
            "template <typename T>",
            "long double pl_distance(const Point<T> &p, const Line<T> &l) { return abs((long double)cross(l.vec(), p - l.begin) / length(l.vec())); }",
            "",
            "// ps_distance",
            "// \u70b9p\u3068\u7dda\u5206s\u306e\u8ddd\u96e2\u3092\u6c42\u3081\u308b.",
            "template <typename T>",
            "long double ps_distance(const Point<T> &p, const Segment<T> &s) {",
            "    if (sgn(dot(s.vec(), p - s.begin)) < 0 || sgn(dot(s.countervec(), p - s.end)) < 0) {",
            "        return min(dist(p, s.begin), dist(p, s.end));",
            "    }",
            "    return pl_distance(p, s);",
            "}",
            "",
            "// ss_distance",
            "// \u7dda\u5206s1\u3068\u7dda\u5206s2\u306e\u8ddd\u96e2\u3092\u6c42\u3081\u308b.",
            "template <typename T>",
            "long double ss_distance(const Segment<T> &s1, const Segment<T> &s2) {",
            "    if (ss_intersection(s1, s2).first) return 0;",
            "    return min({ps_distance(s1.begin, s2), ps_distance(s1.end, s2), ps_distance(s2.begin, s1), ps_distance(s2.end, s1)});",
            "}",
            "",
            "// proj",
            "// \u30d9\u30af\u30c8\u30ebp\u3092\u76f4\u7ddal\u306b\u5c04\u5f71\u3057\u305f\u70b9\u3092\u8fd4\u3059.",
            "Point<long double> proj(const Point<long double> &p, const Line<long double> &l) { return l.begin + normalize(l.vec()) * (dot(l.vec(), p - l.begin) / length(l.vec())); }",
            "",
            "// reflection",
            "// \u30d9\u30af\u30c8\u30ebp\u3092\u76f4\u7ddal\u306b\u5bfe\u3057\u3066\u53cd\u8ee2\u3055\u305b\u305f\u70b9\u3092\u8fd4\u3059.",
            "Point<long double> reflection(const Point<long double> &p, const Line<long double> &l) { return proj(p, l) * 2 - p; }",
            "",
            "// vertical_bisector",
            "// \u70b9p,q\u306e\u5782\u76f4\u4e8c\u7b49\u5206\u7dda\u3092\u6c42\u3081\u308b.",
            "Line<long double> vertical_bisector(const Point<long double> &p, const Point<long double> &q) {",
            "    Point mid = (p + q) / 2, vec = rot90(p - q);",
            "    return Line(mid, mid + vec);",
            "}",
            "",
            "// example:",
            "// using P = Point<int>;",
            "// using L = Line<int>;",
            "// using S = Segment<int>;",
            "// using R = Ray<int>;",
            "//",
            "// using P = Point<long double>;",
            "// using L = Line<long double>;",
            "// using S = Segment<long double>;",
            "// using R = Ray<long double>;"
        ],
        "description": ""
    },
    "./math/prime.cpp": {
        "prefix": "snp prime",
        "body": [
            "",
            "// is_prime",
            "// \u6574\u6570n\u304c\u7d20\u6570\u304b\u3069\u3046\u304b\u5224\u5b9a\u3059\u308b.",
            "// \u5236\u7d04: n >= 1,",
            "// \u8a08\u7b97\u91cf: O(\u221an)",
            "template <typename T>",
            "bool is_prime(T n) {",
            "    for (T i = 2; i * i <= n; i++) {",
            "        if (n % i == 0) return false;",
            "    }",
            "    return n != 1;",
            "}",
            "",
            "// divisor",
            "// \u6574\u6570n\u306e\u56e0\u6570\u3092\u5217\u6319\u3059\u308b.",
            "// \u5236\u7d04: n >= 1",
            "// \u8a08\u7b97\u91cf: O(\u221anlogn)",
            "template <typename T>",
            "vector<T> divisor(T n) {",
            "    vector<T> ans;",
            "    for (int i = 1; i * i <= n; i++) {",
            "        if (n % i == 0) {",
            "            ans.push_back(i);",
            "            if (i != n / i) ans.push_back(n / i);",
            "        }",
            "    }",
            "    sort(ans.begin(), ans.end());",
            "    return ans;",
            "}",
            "",
            "// prime_factor",
            "// \u6574\u6570n\u3092\u7d20\u56e0\u6570\u5206\u89e3\u3057\u305f\u7d50\u679c\u3092\u8fd4\u3059.",
            "// \u5236\u7d04: n >= 1",
            "// \u8a08\u7b97\u91cf: O(\u221an)",
            "template <typename T>",
            "vector<pair<T, int>> prime_factor(T n) {",
            "    vector<pair<T, int>> ans;",
            "    for (T i = 2; i * i <= n; i++) {",
            "        int cnt = 0;",
            "        while (n % i == 0) {",
            "            cnt++;",
            "            n /= i;",
            "        }",
            "        if (cnt > 0) ans.emplace_back(i, cnt);",
            "    }",
            "    if (n != 1) ans.emplace_back(n, 1);",
            "    return ans;",
            "}",
            "",
            "// Eratosthenes",
            "// n\u4ee5\u4e0b\u306e\u6574\u6570\u304c\u7d20\u6570\u304b\u3069\u3046\u304b\u5224\u5b9a\u3059\u308b",
            "// \u5236\u7d04: n >= 1",
            "struct Eratosthenes {",
            "",
            "  private:",
            "    int n;",
            "    vector<int> is_primes, primes;",
            "",
            "  public:",
            "    Eratosthenes(int n) : n(n) {",
            "        is_primes.assign(n + 1, 1);",
            "    }",
            "",
            "    // build",
            "    // n\u4ee5\u4e0b\u306e\u7d20\u6570\u3092\u5168\u3066\u8fd4\u3059",
            "    // \u8a08\u7b97\u91cf: O(nloglogn)",
            "    vector<int> build() {",
            "        is_primes[0] = is_primes[1] = 0;",
            "        for (long long i = 2; i <= n; i++) {",
            "            if (!is_primes[i]) continue;",
            "            primes.push_back(i);",
            "            for (long long j = i * i; j <= n; j += i) {",
            "                is_primes[j] = 0;",
            "            }",
            "        }",
            "        return primes;",
            "    }",
            "",
            "    // is_prime",
            "    // \u6574\u6570p\u304c\u7d20\u6570\u304b\u3069\u3046\u304b\u5224\u5b9a\u3059\u308b",
            "    // \u5236\u7d04: 1 <= p <= n",
            "    bool is_prime(int p) {",
            "        return is_primes[p];",
            "    }",
            "",
            "    // factorize",
            "    // \u6574\u6570m\u3092\u7d20\u56e0\u6570\u5206\u89e3\u3059\u308b",
            "    // \u5236\u7d04: 1 <= m <= n*n",
            "    // \u8a08\u7b97\u91cf: O(min{n,\u221am})",
            "    template <typename T>",
            "    vector<pair<T, int>> factorize(T m) {",
            "        vector<pair<T, int>> ans;",
            "        for (const int &p : primes) {",
            "            if (p > m) break;",
            "            int count = 0;",
            "            while (m % p == 0) {",
            "                count++;",
            "                m /= p;",
            "            }",
            "            if (count > 0) ans.emplace_back(p, count);",
            "        }",
            "        if (m != 1) ans.emplace_back(m, 1);",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./math/zeta.cpp": {
        "prefix": "snp zeta",
        "body": [
            "",
            "// a <= b <=> a <= b",
            "// g[x] = \\\\sum_{ i <= x } f[i]",
            "template <class R>",
            "struct ZetaOrder {",
            "    // TODO:verify",
            "  public:",
            "    ZetaOrder() {}",
            "",
            "    void zeta(std::vector<R> &f) {",
            "        int sz = (int)f.size();",
            "        for (int x = 1; x < sz; x++) {",
            "            f[x] += f[x - 1];",
            "        }",
            "    }",
            "",
            "    void mebius(std::vector<R> &f) {",
            "        int sz = (int)f.size();",
            "        for (int x = sz - 1; x >= 1; x--) {",
            "            f[x] -= f[x - 1];",
            "        }",
            "    }",
            "",
            "    std::vector<R> convolve(std::vector<R> f, std::vector<R> g) {",
            "        int sz = std::max((int)f.size(), (int)g.size());",
            "        f.resize(sz, 0);",
            "        g.resize(sz, 0);",
            "        zeta(f);",
            "        zeta(g);",
            "        std::vector<R> h(sz);",
            "        for (int i = 0; i < sz; i++) {",
            "            h[i] = f[i] * g[i];",
            "        }",
            "        mebius(h);",
            "        return h;",
            "    }",
            "};",
            "",
            "// min_pow2 returns minimum power of 2 larger than x (x <= 2^i)",
            "// and i (pair{i,2^i}).",
            "// x must be more than 0",
            "template <class T>",
            "std::pair<int, T> min_pow2(T x) {",
            "    int i = 0;",
            "    T ret = 1;",
            "    while (x > ret) {",
            "        i++;",
            "        ret <<= 1;",
            "    }",
            "    return std::make_pair(i, ret);",
            "}",
            "",
            "// S <= T <=> S \\subset T",
            "// g[T] = \\sum_{ S \\subset T } f[S]",
            "template <class R>",
            "struct ZetaSubset {",
            "    // TODO:verify",
            "  private:",
            "    // min_pow2 returns minimum power of 2 larger than x (x <= 2^i)",
            "    // and i (pair{i,2^i}).",
            "    // x must be more than 0",
            "    std::pair<int, int> min_pow2(int x) {",
            "        int i   = 0;",
            "        int ret = 1;",
            "        while (x > ret) {",
            "            i++;",
            "            ret <<= 1;",
            "        }",
            "        return std::make_pair(i, ret);",
            "    }",
            "",
            "  public:",
            "    ZetaSubset() {}",
            "",
            "    void zeta(std::vector<R> &f) {",
            "        auto [d, sz] = min_pow2((int)f.size());",
            "        f.resize(sz, (R)0);",
            "        for (int i = 0; i < d; i++) {",
            "            for (int T = 0; T < sz; T++) {",
            "                if (T & (1 << i))",
            "                    f[T] += f[T ^ (1 << i)];",
            "            }",
            "        }",
            "    }",
            "",
            "    void mebius(std::vector<R> &f) {",
            "        auto [d, sz] = min_pow2((int)f.size());",
            "        f.resize(sz, (R)0);",
            "        for (int i = 0; i < d; i++) {",
            "            for (int T = 0; T < sz; T++) {",
            "                if (T & (1 << i))",
            "                    f[T] -= f[T ^ (1 << i)];",
            "            }",
            "        }",
            "    }",
            "",
            "    std::vector<R> convolve(std::vector<R> f, std::vector<R> g) {",
            "        int sz = std::max((int)f.size(), (int)g.size());",
            "        f.resize(sz, 0);",
            "        g.resize(sz, 0);",
            "        zeta(f);",
            "        zeta(g);",
            "        std::vector<R> h(sz);",
            "        for (int i = 0; i < sz; i++) {",
            "            h[i] = f[i] * g[i];",
            "        }",
            "        mebius(h);",
            "        return h;",
            "    }",
            "};",
            "",
            "// a <= b <=> b | a",
            "// g[x] = \\sum_{ x | i } f[i]",
            "template <class R>",
            "struct ZetaDiv {",
            "    // TODO: O(nloglogn) zeta transform",
            "  private:",
            "    // min_pow2 returns minimum power of 2 larger than x (x <= 2^i)",
            "    // and i (pair{i,2^i}).",
            "    // x must be more than 0",
            "    std::pair<int, int> min_pow2(int x) {",
            "        int i   = 0;",
            "        int ret = 1;",
            "        while (x > ret) {",
            "            i++;",
            "            ret <<= 1;",
            "        }",
            "        return std::make_pair(i, ret);",
            "    }",
            "",
            "  public:",
            "    ZetaDiv() {}",
            "",
            "    void zeta(std::vector<R> &f) {",
            "        int sz = (int)f.size();",
            "        for (int x = 1; x < sz; x++) {",
            "            for (int i = 2 * x; i < sz; i += x) {",
            "                f[x] += f[i];",
            "            }",
            "        }",
            "    }",
            "",
            "    void mebius(std::vector<R> &f) {",
            "        int sz = (int)f.size();",
            "        for (int x = sz - 1; x >= 1; x--) {",
            "            for (int i = 2 * x; i < sz; i += x) {",
            "                f[x] -= f[i];",
            "            }",
            "        }",
            "    }",
            "",
            "    std::vector<R> convolve(std::vector<R> f, std::vector<R> g) {",
            "        int sz = std::min((int)f.size(), (int)g.size());",
            "        zeta(f);",
            "        zeta(g);",
            "        std::vector<R> h(sz);",
            "        for (int i = 0; i < sz; i++) {",
            "            h[i] = f[i] * g[i];",
            "        }",
            "        mebius(h);",
            "        return h;",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./math/number_theory.cpp": {
        "prefix": "snp number_theory",
        "body": [
            "",
            "",
            "// gcd",
            "// \u975e\u8ca0\u6574\u6570a,b\u306e\u6700\u5927\u516c\u7d04\u6570\u3092\u6c42\u3081\u308b.",
            "// \u5236\u7d04: a,b >= 0",
            "// \u8a08\u7b97\u91cf: O(logmax(a,b))",
            "template <typename T>",
            "T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }",
            "",
            "// lcm",
            "// \u975e\u8ca0\u6574\u6570a,b\u306e\u6700\u5c0f\u516c\u500d\u6570\u3092\u6c42\u3081\u308b.",
            "// \u5236\u7d04: a,b >= 0",
            "// \u8a08\u7b97\u91cf: O(logmax(a,b))",
            "template <typename T>",
            "T lcm(T a, T b) { return a / gcd(a, b) * b; }",
            "",
            "// ext_gcd",
            "// \u62e1\u5f35Euclid\u306e\u4e92\u9664\u6cd5\u3067\u975e\u8ca0\u6574\u6570a,b\u306b\u5bfe\u3057\u3066ax + by = gcd(a,b)\u3092\u6e80\u305f\u3059\u6574\u6570x,y\u3092\u6c42\u3081\u308b.",
            "// \u51fa\u529b\u3055\u308c\u308b\u5024\u306f xy != 0 \u306a\u3089\u3070 |x| <= b,|y| <= a \u3092\u6e80\u305f\u3059.",
            "// \u5236\u7d04: a,b >= 0",
            "// \u8a08\u7b97\u91cf: O(logmax(a,b))",
            "template <typename T>",
            "pair<T, T> ext_gcd(T a, T b) {",
            "    if (b == 0) {",
            "        return make_pair(1, 0);",
            "    }",
            "    auto [x, y] = ext_gcd(b, a % b);",
            "    return make_pair(y, x - a / b * y);",
            "}",
            "",
            "// pow_mod",
            "// x^k mod m\u3092\u8a08\u7b97\u3059\u308b.",
            "// \u8a08\u7b97\u91cf: O(logk)",
            "template <typename T>",
            "T pow_mod(T x, long long k, int m) {",
            "    T ret = T(1);",
            "    while (k > 0) {",
            "        if (k & 1) {",
            "            ret *= x;",
            "            ret %= m;",
            "        }",
            "        k >>= 1;",
            "        x *= x;",
            "        x %= m;",
            "    }",
            "    return ret;",
            "}",
            "",
            "// inv_mod",
            "// ax = 1 (mod m) \u306a\u308bx (0 <= x < m)\u304c\u5b58\u5728\u3059\u308b\u306a\u3089\u3070",
            "// \u305d\u308c\u3092\u8fd4\u3057, \u5b58\u5728\u3057\u306a\u3051\u308c\u3070-1\u3092\u8fd4\u3059.",
            "// \u8a08\u7b97\u91cf: O(log|max(a,m)|)",
            "template <typename T>",
            "T inv_mod(T a, T m) {",
            "    auto [x, y] = ext_gcd(a, m);",
            "    T g         = a * x + m * y;",
            "    if (g != 1) return -1;",
            "    return (m + x % m) % m;",
            "}",
            "",
            "// linear_congruence",
            "// forall i,A_i x = B_i mod M_i <=> x = b mod m",
            "// \u3068\u304b\u3051\u308b\u3068\u304d\u306b(b,m)\u306e\u7d44\u3092\u8fd4\u3059. \u305f\u3060\u3057(0 <= b < m)\u3092\u307f\u305f\u3059. \u3053\u306e\u3088\u3046\u306b\u66f8\u3051\u306a\u3044\u6642\u306f(-1,-1)\u3092\u8fd4\u3059.",
            "// \u8a08\u7b97\u91cf: O(nlogmax|M_i|),n\u306f\u5f0f\u306e\u6570",
            "template <typename T>",
            "pair<T, T> linear_congruence(const vector<T> &A, const vector<T> &B, const vector<T> &M) {",
            "    T x = 0, m = 1;",
            "    for (int i = 0; i < (int)A.size(); i++) {",
            "        T a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);",
            "        if (b % d != 0) return make_pair(-1, -1);",
            "        T t = b / d * inv_mod(a / d, M[i] / d) % (M[i] / d);",
            "        x += m * t;",
            "        m *= M[i] / d;",
            "    }",
            "    return make_pair((m + x % m) % m, m);",
            "}",
            "",
            "// garner",
            "// forall i, x = R_i mod M_i <=> x = b mod m",
            "// \u3068\u304b\u3051\u308b\u3068\u304d\u306b(b,m)\u306e\u7d44\u3092\u8fd4\u3059. \u305f\u3060\u3057(0 <= b < m)\u3092\u307f\u305f\u3059. \u3053\u306e\u3088\u3046\u306b\u66f8\u3051\u306a\u3044\u6642\u306f(-1,-1)\u3092\u8fd4\u3059.",
            "// \u8a08\u7b97\u91cf: O(nlogmax|M_i|),n\u306f\u5f0f\u306e\u6570",
            "template <typename T>",
            "pair<T, T> garner(const vector<T> &R, const vector<T> &M) {",
            "    vector<T> A(R.size(), 1);",
            "    return linear_congruence(A, R, M);",
            "}",
            "",
            "// a\u306ek\u4e57\u6839\u3092\u6c42\u3081\u308b",
            "long long root_int(long long a, int k) {",
            "    if (k == 0) return 0;",
            "    long long x = pow(a, (double)1.0 / k);",
            "    while (pow(x, k) > a)",
            "        x--;",
            "    while (pow(x + 1, k) <= a)",
            "        x++;",
            "    return x;",
            "}"
        ],
        "description": ""
    },
    "./math/kitamasa.cpp": {
        "prefix": "snp kitamasa",
        "body": [
            "",
            "// Kitamasa",
            "// \u521d\u671f\u5024: A_0,A_1,...A_{k-1}",
            "// \u7dda\u5f62\u6f38\u5316\u5f0f: A_n = D_0A_{n-k} + ... D_{k-1}A_{n-1}",
            "// \u304c\u4e0e\u3048\u3089\u308c\u305f\u3068\u304d\u306b",
            "// A_n\u3092O(k^2logn)\u3067\u6c42\u3081\u308b.",
            "template <typename T>",
            "struct Kitamasa {",
            "    int k;",
            "    vector<T> init, coef;",
            "",
            "    Kitamasa(vector<T> &init, vector<T> &coef) : init(init), coef(coef) {",
            "        k = (int)coef.size();",
            "    }",
            "",
            "    // solve",
            "    // \u5236\u7d04: n >= 0",
            "    // \u8a08\u7b97\u91cf: O(k^2logn)",
            "    T solve(long long n) {",
            "        if (n == 0) return init[0];",
            "        vector<T> ret(k, 0);",
            "        ret[1] = 1;",
            "",
            "        int msb = get_msb(n);",
            "        for (int i = msb - 1; i >= 0; i--) {",
            "            ret = mul2(ret);",
            "            if ((n >> i) & 1) {",
            "                ret = add1(ret);",
            "            }",
            "        }",
            "        T ans = T(0);",
            "        for (int i = 0; i < k; i++)",
            "            ans += init[i] * ret[i];",
            "        return ans;",
            "    }",
            "",
            "    int get_msb(long long n) {",
            "        for (int i = 63; i >= 0; i--) {",
            "            if ((n >> i) & 1) return i;",
            "        }",
            "        return -1;",
            "    }",
            "",
            "    vector<T> add1(vector<T> &ret) {",
            "        vector<T> ans(k, 0);",
            "        for (int i = 0; i < k; i++) {",
            "            if (i == 0)",
            "                ans[i] = coef[0] * ret[k - 1];",
            "            else",
            "                ans[i] = ret[i - 1] + coef[i] * ret[k - 1];",
            "        }",
            "        return ans;",
            "    }",
            "",
            "    vector<T> mul2(vector<T> &ret) {",
            "        vector<T> ans(k, 0), k0 = ret;",
            "        for (int i = 0; i < k; i++) {",
            "            for (int j = 0; j < k; j++) {",
            "                ans[j] += k0[i] * ret[j];",
            "            }",
            "            ret = add1(ret);",
            "        }",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./math/osa_k.cpp": {
        "prefix": "snp osa_k",
        "body": [
            "",
            "// OsaK",
            "// n\u4ee5\u4e0b\u306e\u6574\u6570\u306e\u7d20\u56e0\u6570\u5206\u89e3\u3092\u9ad8\u901f\u306b\u884c\u3046.",
            "// \u5236\u7d04: n >= 1",
            "struct OsaK {",
            "    int n;",
            "    vector<int> smallest_prime_factor;",
            "",
            "    OsaK(int n) : n(n) {",
            "        smallest_prime_factor.assign(n + 1, -1);",
            "    }",
            "",
            "    // build",
            "    // spf\u914d\u5217\u3092\u7528\u610f\u3059\u308b.",
            "    // \u8a08\u7b97\u91cf: O(nloglogn)",
            "    void build() {",
            "        long long i = 2;",
            "        for (; i * i <= n; ++i) {",
            "            if (smallest_prime_factor[i] < 0) {",
            "                smallest_prime_factor[i] = i;",
            "                for (long long p = i * i; p <= n; p += i) {",
            "                    if (smallest_prime_factor[p] < 0) smallest_prime_factor[p] = i;",
            "                }",
            "            }",
            "        }",
            "        for (int j = i; j <= n; ++j) {",
            "            if (smallest_prime_factor[j] < 0) smallest_prime_factor[j] = j;",
            "        }",
            "    }",
            "",
            "    // factorize",
            "    // \u6574\u6570m\u3092\u7d20\u56e0\u6570\u5206\u89e3\u3059\u308b",
            "    // \u5236\u7d04: 1 <= m <= n",
            "    // \u8a08\u7b97\u91cf: O(logm)",
            "    template <typename T>",
            "    vector<pair<T, int>> factorize(T m) {",
            "        vector<pair<T, int>> ans;",
            "        while (m > 1) {",
            "            int p = smallest_prime_factor[m], e = 1;",
            "            m /= p;",
            "            while (p == smallest_prime_factor[m]) {",
            "                ++e;",
            "                m /= p;",
            "            }",
            "            ans.emplace_back(p, e);",
            "        }",
            "        return ans;",
            "    }",
            "",
            "    // count_factor",
            "    // \u6574\u6570m\u306e\u7d04\u6570\u306e\u6570\u3092\u6570\u3048\u308b.",
            "    // \u5236\u7d04: 1 <= m <= n",
            "    // \u8a08\u7b97\u91cf: O(logm)",
            "    template <typename T>",
            "    long long count_factor(T m) {",
            "        auto ret      = factorize(m);",
            "        long long ans = 1;",
            "        for (const auto &p : ret) {",
            "            ans *= (p.second + 1);",
            "        }",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./math/bell_number.cpp": {
        "prefix": "snp bell_number",
        "body": [
            "",
            "",
            "// StirlingNumber2",
            "// n\u500b\u306e\u533a\u5225\u3067\u304d\u308b\u3082\u306e\u3092k\u500b\u306e\u533a\u5225\u3067\u304d\u306a\u3044\u7bb1\u306b1\u500b\u4ee5\u4e0a\u306b\u5206\u5272\u3059\u308b\u65b9\u6cd5\u304c\u4f55\u901a\u308a\u3042\u308b\u304b\u6c42\u3081\u308b.",
            "// \u3053\u308c\u3092S(n,k)\u3068\u3059\u308b. \u7b2c\u4e8c\u7a2e\u30b9\u30bf\u30fc\u30ea\u30f3\u30b0\u6570",
            "template <typename T>",
            "struct StirlingNumber2 {",
            "    int n, k;",
            "    vector<vector<T>> dp;",
            "",
            "    StirlingNumber2(int n, int k) : n(n), k(k) {",
            "        dp.assign(n + 1, vector<T>(k + 1, T(0)));",
            "    }",
            "",
            "    // solve",
            "    // S(i,j) (0 <= i <= n, 0 <= j <= k)\u3092\u6c42\u3081\u308b.",
            "    // \u8a08\u7b97\u91cf: O(nk)",
            "    T solve() {",
            "        dp[0][0] = T(1);",
            "        for (int i = 1; i <= n; i++) {",
            "            for (int j = 0; j <= k; j++) {",
            "                dp[i][j] = T(j) * dp[i - 1][j];",
            "                if (j > 0) dp[i][j] += dp[i - 1][j - 1];",
            "            }",
            "        }",
            "        return dp[n][k];",
            "    }",
            "",
            "    // S(i,j)\u3092\u8fd4\u3059.",
            "    // \u5236\u7d04: 0 <= i <= n, 0 <= j <= k",
            "    T operator()(int i, int j) {",
            "        return dp[i][j];",
            "    }",
            "};",
            "",
            "// BellNumber",
            "// n\u500b\u306e\u533a\u5225\u3067\u304d\u308b\u3082\u306e\u3092k\u500b\u306e\u533a\u5225\u3067\u304d\u306a\u3044\u7bb1\u306b0\u500b\u4ee5\u4e0a\u306b\u5206\u5272\u3059\u308b\u65b9\u6cd5\u304c\u4f55\u901a\u308a\u3042\u308b\u304b\u6c42\u3081\u308b.",
            "// \u3053\u308c\u3092B(n,k)\u3068\u3057\u3066\u30d9\u30eb\u6570\u3068\u3044\u3046.",
            "template <typename T>",
            "struct BellNumber {",
            "    int n, k;",
            "    vector<vector<T>> dp;",
            "",
            "    BellNumber(int n, int k) : n(n), k(k) {",
            "        dp.assign(n + 1, vector<T>(k + 1, T(0)));",
            "    }",
            "",
            "    // solve",
            "    // 0 <= i <= n,0 <= j <= k\u306b\u3064\u3044\u3066B(i,j)\u3092\u6c42\u3081\u308b.",
            "    // \u8a08\u7b97\u91cf: O(nk)",
            "    T solve() {",
            "        StirlingNumber2<T> s2(n, k);",
            "        s2.solve();",
            "        for (int i = 0; i <= n; i++) {",
            "            for (int j = 1; j <= k; j++) {",
            "                dp[i][j] = dp[i][j - 1] + s2(i, j);",
            "            }",
            "        }",
            "        return dp[n][k];",
            "    }",
            "",
            "    // B(i,j)\u3092\u8fd4\u3059.",
            "    // \u5236\u7d04: 0 <= i <= n, 0 <= j <= k",
            "    T operator()(int i, int j) {",
            "        return dp[i][j];",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./dynamic_programming/edit_distance.cpp": {
        "prefix": "snp edit_distance",
        "body": [
            "",
            "",
            "// edit_distance",
            "// \u6587\u5b57\u5217s,\u6587\u5b57\u5217t\u306e\u7de8\u96c6\u8ddd\u96e2, \u3059\u306a\u308f\u3061\u4ee5\u4e0b\u306e\u64cd\u4f5c\u3092\u3057\u3066s\u3092t\u306b\u7b49\u3057\u304f\u3059\u308b\u305f\u3081\u306b\u5fc5\u8981\u306a\u64cd\u4f5c\u56de\u6570\u306e\u6700\u5c0f\u5024",
            "// 1. s\u304b\u3089\u6587\u5b57\u3092\u4e00\u3064\u53d6\u308a\u9664\u304f",
            "// 2. s\u306b\u6587\u5b57\u3092\u4e00\u3064\u633f\u5165\u3059\u308b",
            "// 3. s\u306e\u6587\u5b57\u3092\u4e00\u3064\u5909\u63db\u3059\u308b",
            "// \u8a08\u7b97\u91cf: O(|S||T|)",
            "int edit_distance(string s, string t) {",
            "    int n = (int)s.size(), m = (int)t.size();",
            "    vector<vector<int>> dp(n + 1, vector<int>(m + 1, INF));",
            "    for (int j = 0; j <= m; j++)",
            "        dp[0][j] = j;",
            "    for (int i = 0; i <= n; i++) {",
            "        dp[i][0] = i;",
            "    }",
            "    for (int i = 0; i < n; i++) {",
            "        for (int j = 0; j < m; j++) {",
            "            if (s[i] == t[j]) dp[i + 1][j + 1] = dp[i][j];",
            "            dp[i + 1][j + 1] = min({dp[i + 1][j + 1], dp[i][j + 1] + 1, dp[i + 1][j] + 1, dp[i][j] + 1});",
            "        }",
            "    }",
            "    return dp[n][m];",
            "}"
        ],
        "description": ""
    },
    "./dynamic_programming/longest_common_sequence.cpp": {
        "prefix": "snp longest_common_sequence",
        "body": [
            "",
            "struct LongestCommonSequence {",
            "    int n, m;",
            "    string s, t, ret;",
            "    vector<vector<int>> dp;",
            "",
            "    LongestCommonSequence(string s, string t) : s(s), t(t) {",
            "        n = (int)s.size();",
            "        m = (int)t.size();",
            "        dp.assign(n + 1, vector<int>(m + 1, 0));",
            "    }",
            "",
            "    // solve",
            "    // \u6700\u9577\u5171\u901a\u90e8\u5206\u5217\u554f\u984c\u3092\u89e3\u3044\u3066\u305d\u306e\u9577\u3055\u3092\u8fd4\u3059\u3002",
            "    // \u8a08\u7b97\u91cf: O(nm)",
            "    int solve() {",
            "        for (int i = 0; i < n; i++) {",
            "            for (int j = 0; j < m; j++) {",
            "                if (s[i] == t[j]) {",
            "                    dp[i + 1][j + 1] = dp[i][j] + 1;",
            "                } else {",
            "                    dp[i + 1][j + 1] = max(dp[i + 1][j], dp[i][j + 1]);",
            "                }",
            "            }",
            "        }",
            "        return dp[n][m];",
            "    }",
            "",
            "    // restore_common_string",
            "    // \u6700\u9577\u5171\u901a\u90e8\u5206\u5217(\u6587\u5b57\u5217)\u3092\u8fd4\u3059",
            "    // \u8a08\u7b97\u91cf: O(l),l\u306f\u6700\u9577\u5171\u901a\u90e8\u5206\u5217\u306e\u9577\u3055",
            "    string restore_common_string() {",
            "        vector<char> ret;",
            "        int ni = n, nj = m;",
            "        while (ni != 0 && nj != 0) {",
            "            if (s[ni - 1] == t[nj - 1]) {",
            "                ret.push_back(s[ni - 1]);",
            "                ni--;",
            "                nj--;",
            "            } else {",
            "                if (dp[ni][nj] == dp[ni - 1][nj])",
            "                    ni--;",
            "                else",
            "                    nj--;",
            "            }",
            "        }",
            "        reverse(ret.begin(), ret.end());",
            "        string ans = \"\";",
            "        for (auto &c : ret)",
            "            ans += c;",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./dynamic_programming/longest_increasing_sequence.cpp": {
        "prefix": "snp longest_increasing_sequence",
        "body": [
            "",
            "// LongestIncreasingSequece",
            "// A\u306e\u6700\u9577\u5897\u52a0\u90e8\u5206\u5217\u3092\u6c42\u3081\u308b. \u3059\u306a\u308f\u3061",
            "// 0 <= i1 < i2 < ... < ik < n, A[i1] < A[i2] < ... < A[ik]\u306a\u308bk\u306e\u6700\u5927\u5024\u3092\u6c42\u3081\u308b\u3002",
            "template <typename T, T INF>",
            "struct LongestIncreasingSequence {",
            "",
            "    // dp[i] = \u9577\u3055i+1\u3067\u3042\u308b\u3088\u3046\u306a\u5897\u52a0\u90e8\u5206\u5217\u3067\u306e\u6700\u5f8c\u306e\u8981\u7d20\u306e\u6700\u5c0f\u5024, \u306a\u3044\u5834\u5408\u306fINF",
            "    // dp_ind[i] = \u9577\u3055i+1\u3067\u3042\u308b\u3088\u3046\u306a\u5897\u52a0\u90e8\u5206\u5217\u3067\u306e\u6700\u5f8c\u306e\u8981\u7d20\u306e\u6700\u5c0f\u5024\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9, \u306a\u3044\u5834\u5408\u306f-1",
            "    // prev[i] = A[i]\u3092\u542b\u3080\u4e2d\u3067\u6700\u9577\u306e\u5897\u52a0\u90e8\u5206\u5217\u3067\u306eA[i]\u306e\u524d\u306e\u8981\u7d20\u304cA[j]\u3067\u3042\u308b\u3068\u304dj, \u5148\u982d\u306e\u3068\u304d\u306f-1",
            "    int n;",
            "    vector<T> A, dp;",
            "    vector<int> prev, dp_ind;",
            "",
            "    LongestIncreasingSequence(int n, vector<T> &A) : n(n), A(A) {",
            "        dp.assign(n + 1, INF);",
            "        dp_ind.assign(n + 1, -1);",
            "        prev.assign(n, -1);",
            "    }",
            "",
            "    // solve",
            "    // A\u306e\u6700\u9577\u5897\u52a0\u90e8\u5206\u5217\u3092\u6c42\u3081\u308b.",
            "    // \u8a08\u7b97\u91cf: O(nlogn)",
            "    int solve() {",
            "        for (int i = 0; i < n; i++) {",
            "            int j     = lower_bound(dp.begin(), dp.end(), A[i]) - dp.begin();",
            "            dp[j]     = A[i];",
            "            dp_ind[j] = i;",
            "            prev[i]   = (j > 0 ? dp_ind[j - 1] : -1);",
            "        }",
            "        return lower_bound(dp.begin(), dp.end(), INF) - dp.begin();",
            "    }",
            "",
            "    // restore_lis",
            "    // \u6700\u9577\u5897\u52a0\u90e8\u5206\u5217\u3092\u5fa9\u5143\u3059\u308b",
            "    // \u8a08\u7b97\u91cf: O(l),l\u306f\u6700\u9577\u5897\u52a0\u90e8\u5206\u5217\u306e\u9577\u3055",
            "    vector<T> restore_lis() {",
            "        vector<T> ans;",
            "        int max_len = lower_bound(dp.begin(), dp.end(), INF) - dp.begin();",
            "        for (int now_ind = dp_ind[max_len - 1]; now_ind >= 0; now_ind = prev[now_ind])",
            "            ans.push_back(A[now_ind]);",
            "        reverse(ans.begin(), ans.end());",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./other_algorithm/compress.cpp": {
        "prefix": "snp compress",
        "body": [
            "",
            "template <typename T>",
            "struct Compress {",
            "  private:",
            "    int n;",
            "    vector<T> A;",
            "    map<T, int> val_to_id;",
            "",
            "  public:",
            "    Compress(const vector<T> &_A) : A(_A) {",
            "        sort(A.begin(), A.end());",
            "        A.erase(unique(A.begin(), A.end()), A.end());",
            "        n = (int)A.size();",
            "        for (int i = 0; i < n; i++)",
            "            val_to_id[A[i]] = i;",
            "    }",
            "",
            "    int operator()(T val) {",
            "        return val_to_id[val];",
            "    }",
            "",
            "    T operator[](int id) {",
            "        return A[id];",
            "    }",
            "",
            "    int size() {",
            "        return n;",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./other_algorithm/two_pointers.cpp": {
        "prefix": "snp two_pointers",
        "body": [
            "",
            "// TwoPointers",
            "// \u6761\u4ef6P\u3092\u6e80\u305f\u3059\u9023\u7d9a\u90e8\u5206\u5217[l,r)\u306e\u6570\u3048\u4e0a\u3052, \u3082\u3057\u304f\u306f\u6700\u5927\u306e\u9577\u3055\u3092\u8a08\u7b97\u3059\u308b.",
            "// \u305f\u3060\u3057\u6761\u4ef6P\u306f\u4ee5\u4e0b\u306e\u6761\u4ef6\u3092\u6e80\u305f\u3059\u3088\u3046\u306a\u3082\u306e\u3067\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044.",
            "// \u6761\u4ef6",
            "// - \u9023\u7d9a\u90e8\u5206\u5217[l,r)\u304c\u6761\u4ef6P\u3092\u6e80\u305f\u3059\u3068\u304d, [l,r)\u5185\u306e\u4efb\u610f\u306e\u9023\u7d9a\u90e8\u5206\u5217\u304c\u6761\u4ef6P\u3092\u6e80\u305f\u3059.",
            "//",
            "template <typename Data, const Data initial_state>",
            "struct TwoPointers {",
            "    using Fcond = function<bool(Data data, int r)>;",
            "    using Fincl = function<void(Data &data, int &l)>;",
            "    using Fincr = function<void(Data &data, int &r)>;",
            "",
            "    int n;",
            "    long long count = 0;",
            "    int max_length  = 0;",
            "",
            "  private:",
            "    Data data = initial_state;",
            "",
            "    // cond",
            "    // data\u306f\u9023\u7d9a\u90e8\u5206\u5217[l,r-1)\u306b\u95a2\u3059\u308b\u60c5\u5831\u3092\u6301\u3063\u3066\u304a\u308a, [l,r)\u304c\u6761\u4ef6P\u3092\u6e80\u305f\u3059\u5834\u5408\u306ftrue,\u305d\u3046\u3067\u306a\u3044\u6642\u306ffalse\u3092\u8fd4\u3059.",
            "    // \u5236\u7d04: 0 <= l < r <= n",
            "    Fcond cond;",
            "",
            "    // increase_l",
            "    // l\u3092l+1\u306b\u3059\u308b. \u540c\u6642\u306b\u30c7\u30fc\u30bf\u306e\u5909\u66f4\u3092\u884c\u3046.",
            "    // \u5236\u7d04: 0 <= l < n",
            "    Fincl increase_l;",
            "",
            "    // increase_r",
            "    // r\u3092r+1\u306b\u3059\u308b. \u540c\u6642\u306b\u30c7\u30fc\u30bf\u306e\u5909\u66f4\u3092\u884c\u3046.",
            "    // \u5236\u7d04: 0 <= r < n",
            "    Fincr increase_r;",
            "",
            "    void init() {",
            "        count      = 0;",
            "        max_length = 0;",
            "        data       = initial_state;",
            "    }",
            "",
            "  public:",
            "    TwoPointers(int n, Fcond cond, Fincl increase_l, Fincr increase_r)",
            "        : n(n), cond(cond), increase_l(increase_l), increase_r(increase_r) {}",
            "",
            "    // solve",
            "    // \u5c3a\u53d6\u6cd5\u3092\u7528\u3044\u3066\u6761\u4ef6P\u3092\u6e80\u305f\u3059\u9023\u7d9a\u90e8\u5206\u5217\u306e\u6700\u5927\u306e\u9577\u3055\u3068\u6570\u3092\u6570\u3048\u308b.",
            "    // \u8a08\u7b97\u91cf: O(n)",
            "    void solve() {",
            "        init();",
            "        int r = 0;",
            "        for (int l = 0; l < n; increase_l(data, l)) {",
            "            while (r < n && cond(data, r + 1)) {",
            "                increase_r(data, r);",
            "            }",
            "            count += r - l;",
            "            max_length = max(max_length, r - l);",
            "            if (r == l)",
            "                increase_r(data, r);",
            "        }",
            "    }",
            "};",
            "",
            "// \u672aVerify",
            "// TwoPointers2",
            "// \u6761\u4ef6Q\u3092\u6e80\u305f\u3059\u9023\u7d9a\u90e8\u5206\u5217[l,r)\u306e\u6570\u3048\u4e0a\u3052, \u3082\u3057\u304f\u306f\u6700\u5c0f\u306e\u9577\u3055\u3092\u8a08\u7b97\u3059\u308b.",
            "// \u305f\u3060\u3057\u6761\u4ef6Q\u306f\u4ee5\u4e0b\u306e\u6761\u4ef6\u3092\u6e80\u305f\u3059\u3088\u3046\u306a\u3082\u306e\u3067\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044.",
            "// \u6761\u4ef6",
            "// - \u9023\u7d9a\u90e8\u5206\u5217[l,r)\u304c\u6761\u4ef6Q\u3092\u6e80\u305f\u3059\u3068\u304d, [l,r)\u3092\u542b\u3080\u4efb\u610f\u306e\u9023\u7d9a\u90e8\u5206\u5217\u304c\u6761\u4ef6Q\u3092\u6e80\u305f\u3059.",
            "//",
            "template <typename Data, const Data initial_state>",
            "struct TwoPointers2 {",
            "    using Fcond = function<bool(Data data)>;",
            "    using Fincl = function<void(Data &data, int &l)>;",
            "    using Fincr = function<void(Data &data, int &r)>;",
            "",
            "    int n;",
            "    long long count;",
            "    int min_length;",
            "",
            "  private:",
            "    Data data = initial_state;",
            "",
            "    // cond",
            "    // data\u306f\u9023\u7d9a\u90e8\u5206\u5217[l,r)\u306b\u95a2\u3059\u308b\u60c5\u5831\u3092\u6301\u3063\u3066\u304a\u308a, [l,r)\u304c\u6761\u4ef6Q\u3092\u6e80\u305f\u3059\u5834\u5408\u306ftrue,\u305d\u3046\u3067\u306a\u3044\u6642\u306ffalse\u3092\u8fd4\u3059.",
            "    // \u5236\u7d04: 0 <= l < r <= n",
            "    Fcond cond;",
            "",
            "    // increase_l",
            "    // l\u3092l+1\u306b\u3059\u308b. \u540c\u6642\u306b\u30c7\u30fc\u30bf\u306e\u5909\u66f4\u3092\u884c\u3046.",
            "    // \u5236\u7d04: 0 <= l < n",
            "    Fincl increase_l;",
            "",
            "    // increase_r",
            "    // r\u3092r+1\u306b\u3059\u308b. \u540c\u6642\u306b\u30c7\u30fc\u30bf\u306e\u5909\u66f4\u3092\u884c\u3046.",
            "    // \u5236\u7d04: 0 <= r < n",
            "    Fincr increase_r;",
            "",
            "    void init() {",
            "        count      = 0;",
            "        min_length = n + 1;",
            "        data       = initial_state;",
            "    }",
            "",
            "  public:",
            "    TwoPointers2(int n, Fcond cond, Fincl increase_l, Fincr increase_r)",
            "        : n(n), cond(cond), increase_l(increase_l), increase_r(increase_r) {}",
            "",
            "    // solve",
            "    // \u5c3a\u53d6\u6cd5\u3092\u7528\u3044\u3066\u6761\u4ef6Q\u3092\u6e80\u305f\u3059\u9023\u7d9a\u90e8\u5206\u5217\u306e\u6700\u5c0f\u306e\u9577\u3055\u3068\u6570\u3092\u6570\u3048\u308b.",
            "    // \u8a08\u7b97\u91cf: O(n)",
            "    void solve() {",
            "        init();",
            "        int r = 0;",
            "        for (int l = 0; l < n; increse_l(data, l)) {",
            "            while (r <= n && !cond(data)) {",
            "                if (r == n) {",
            "                    r++;",
            "                    break;",
            "                }",
            "                increase_r(data, r);",
            "            }",
            "            if (r == n + 1) break;",
            "            count += n - r + 1;",
            "            min_length = min(min_length, r - l);",
            "            if (r == l)",
            "                increase_r(data, r);",
            "        }",
            "    }",
            "};",
            "",
            "// \u4f7f\u7528\u4f8b",
            "// https://atcoder.jp/contests/abc032/submissions/34471465",
            "// https://atcoder.jp/contests/abc038/submissions/34471634",
            "//",
            "// using Data = long long;",
            "// TwoPointers<Data, 0> tp(",
            "//     n,",
            "//     [&](Data data, int r) { return data + A[r - 1] <= x; },",
            "//     [&](Data &data, int &l) { data -= A[l]; l++; },",
            "//     [&](Data &data, int &r) { data += A[r]; r++; });"
        ],
        "description": ""
    },
    "./other_algorithm/perm_search.cpp": {
        "prefix": "snp perm_search",
        "body": [
            "",
            "// PermSearch",
            "// \u9806\u5217\u3092\u5168\u63a2\u7d22\u3059\u308b.",
            "// 0~n-1\u307e\u3067\u306e\u6570\u5b57\u304b\u3089\u306a\u308b\u9806\u5217\u3092\u63a2\u7d22\u3059\u308b. f\u306f\u3042\u308b\u9806\u5217\u3092vector\u3067\u53d7\u3051\u53d6\u3063\u3066\u51e6\u7406\u3092\u3059\u308b\u95a2\u6570",
            "struct PermSearch {",
            "    int n;",
            "    vector<int> A;",
            "    function<void(vector<int> &)> f;",
            "",
            "    PermSearch(int n, function<void(vector<int> &)> f) : n(n), f(f) {",
            "        A.resize(n);",
            "    }",
            "",
            "    // solve",
            "    // \u8a08\u7b97\u91cf\u306fO(n!)",
            "    void solve() {",
            "        iota(A.begin(), A.end(), 0);",
            "        do {",
            "            f(A);",
            "        } while (next_permutation(A.begin(), A.end()));",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./other_algorithm/index_generator.cpp": {
        "prefix": "snp index_generator",
        "body": [
            "",
            "// Grid\u306e(i,j)\u306a\u308b\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u30921\u6b21\u5143\u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u306b\u76f4\u3059",
            "",
            "template <typename T>",
            "struct IndexGenerator {",
            "    T H, W;",
            "    IndexGenerator(T H, T W) : H(H), W(W) {}",
            "    T N() { return H * W; }",
            "    T operator()(T i, T j) { return i * W + j; }",
            "};"
        ],
        "description": ""
    },
    "./other_algorithm/grid_utils.cpp": {
        "prefix": "snp grid_utils",
        "body": [
            "",
            "const int dy[8] = {-1, 0, 1, 0, -1, -1, 1, 1};",
            "const int dx[8] = {0, 1, 0, -1, -1, 1, -1, 1};",
            "bool IN(int y, int x, int H, int W) { return (0 <= y) && (y < H) && (0 <= x) && (x < W); }"
        ],
        "description": ""
    },
    "./other_algorithm/mo.cpp": {
        "prefix": "snp mo",
        "body": [
            "",
            "struct Mo {",
            "    int N, Q, width, l, r;",
            "    vector<int> L, R, idx;",
            "    using T = int;",
            "    T ret;",
            "    vector<T> ans;",
            "",
            "    Mo(int N, int Q) : N(N), Q(Q) {",
            "        int width = sqrt(N);",
            "        L.resize(Q);",
            "        R.resize(Q);",
            "        idx.resize(Q);",
            "        ans.resize(Q);",
            "    }",
            "    void add_query(int i, int l, int r) { // ith query is [l,r)",
            "        idx[i] = i;",
            "        L[i]   = l;",
            "        R[i]   = r;",
            "    }",
            "    void build() {",
            "        sort(idx.begin(), idx.end(), [&](int a, int b) {",
            "            return L[a] / width == L[b] / width ? R[a] < R[b] : L[a] < L[b];",
            "        });",
            "        l = 0;",
            "        r = 0;",
            "    }",
            "    void del(int i) { //\u533a\u9593\u3092\u7e2e\u3081\u308b",
            "    }",
            "    void add(int i) { //\u533a\u9593\u3092\u5e83\u3052\u308b",
            "    }",
            "    T process(int i) { //[l,r)",
            "        i = idx[i];",
            "        while (l > L[i])",
            "            add(--l);",
            "        while (r < R[i])",
            "            add(r++);",
            "        while (l < L[i])",
            "            del(l++);",
            "        while (r > R[i])",
            "            del(--r);",
            "        return ans[i] = ret;",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./graph/lowlink.cpp": {
        "prefix": "snp lowlink",
        "body": [
            "",
            "struct LowLink {",
            "    int N;",
            "    vector<vector<int>> G;",
            "    vector<int> low, ord, articulation;",
            "    vector<pair<int,int>> bridge;",
            "",
            "    LowLink(int N, vector<vector<int>> &G) : N(N), G(G) {",
            "        low.assign(N, -1);",
            "        ord.assign(N, -1);",
            "    }",
            "",
            "    void dfs(int v, int time, int p = -1) {",
            "        ord[v] = low[v] = time;",
            "        ++time;",
            "",
            "        bool isArticulation = false;",
            "        int cnt             = 0;",
            "",
            "        for (int e : G[v]) {",
            "            if (low[e] < 0) {",
            "                ++cnt;",
            "                dfs(e, time, v);",
            "                low[v] = min(low[v], low[e]);",
            "                if (p != -1 && ord[v] <= low[e]) isArticulation = true;",
            "                if (ord[v] < low[e]) bridge.push_back({v, e});",
            "            } else if (p != e) {",
            "                low[v] = min(low[v], ord[e]);",
            "            }",
            "        }",
            "",
            "        if (p == -1 && cnt >= 2) isArticulation = true;",
            "        if (isArticulation) articulation.push_back(v);",
            "    }",
            "",
            "    void build() {",
            "        dfs(0, 0);",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./graph/primal_dual.cpp": {
        "prefix": "snp primal_dual",
        "body": [
            "",
            "// PrimalDual",
            "// \u30dd\u30c6\u30f3\u30b7\u30e3\u30eb\u3092\u7528\u3044\u3066\u6700\u5c0f\u8cbb\u7528\u6d41\u3092\u6c42\u3081\u308b.",
            "// \u6700\u521d\u306e\u30b0\u30e9\u30d5\u306b\u306f\u8ca0\u9589\u8def\u304c\u542b\u307e\u308c\u3066\u306f\u3044\u3051\u306a\u3044.",
            "template <typename Cap, typename Cost, const Cost INF>",
            "struct PrimalDual {",
            "    struct edge {",
            "        int to;",
            "        Cap cap;",
            "        Cost cost;",
            "        int rev;",
            "    };",
            "",
            "    int n;",
            "    vector<vector<edge>> G;",
            "    vector<Cost> dist, h;",
            "    vector<int> prevv, preve;",
            "    bool has_negative;",
            "",
            "    PrimalDual(int n) : n(n) {",
            "        G.resize(n);",
            "        dist.resize(n);",
            "        h.resize(n);",
            "        prevv.resize(n);",
            "        preve.resize(n);",
            "        has_negative = false;",
            "    }",
            "",
            "    // add_edge",
            "    // from\u304b\u3089to\u3078\u5bb9\u91cfcap, \u30b3\u30b9\u30c8cost\u306e\u8fba\u3092\u5f35\u308b.",
            "    // \u5236\u7d04: 0 <= from,to < n,cap >= 0,",
            "    void add_edge(int from, int to, Cap cap, Cost cost) {",
            "        G[from].push_back((edge){to, cap, cost, (int)G[to].size()});",
            "        G[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});",
            "        if (cost < 0) has_negative = true;",
            "    }",
            "",
            "    // beruman",
            "    int beruman(int s, int t) {",
            "        fill(dist.begin(), dist.end(), INF);",
            "        dist[s]     = 0;",
            "        bool update = true;",
            "        while (update) {",
            "            update = false;",
            "            for (int v = 0; v < n; v++) {",
            "                if (dist[v] == INF) continue;",
            "                for (int i = 0; i < (int)G[v].size(); i++) {",
            "                    edge &e = G[v][i];",
            "                    if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {",
            "                        dist[e.to]  = dist[v] + e.cost;",
            "                        prevv[e.to] = v;",
            "                        preve[e.to] = i;",
            "                        update      = true;",
            "                    }",
            "                }",
            "            }",
            "        }",
            "        return dist[t] < INF;",
            "    }",
            "",
            "    using P = pair<Cost, int>;",
            "    bool dijkstra(int s, int t) {",
            "        priority_queue<P, vector<P>, greater<P>> q;",
            "        q.push(P{0, s});",
            "        fill(dist.begin(), dist.end(), INF);",
            "        dist[s] = 0;",
            "        while (!q.empty()) {",
            "            auto [d, v] = q.top();",
            "            q.pop();",
            "            if (dist[v] < d) continue;",
            "            for (int i = 0; i < (int)G[v].size(); i++) {",
            "                edge &e = G[v][i];",
            "                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {",
            "                    dist[e.to]  = dist[v] + e.cost + h[v] - h[e.to];",
            "                    prevv[e.to] = v;",
            "                    preve[e.to] = i;",
            "                    q.push(P{dist[e.to], e.to});",
            "                }",
            "            }",
            "        }",
            "        return dist[t] < INF;",
            "    }",
            "",
            "    // solve",
            "    // s\u304b\u3089t\u3078f\u3060\u3051\u6d41\u3059\u305f\u3081\u306e\u6700\u5c0f\u8cbb\u7528\u3092\u6c42\u3081\u308b.",
            "    // \u5236\u7d04: 0 <= s,t < n,f >= 0",
            "    // \u8a08\u7b97\u91cf: O(|V||E| + f|E|log|V|)",
            "    pair<Cap, Cost> solve(int s, int t, Cap f) {",
            "        Cost ret_cost    = 0;",
            "        Cap ret_flow     = 0;",
            "        bool use_beruman = has_negative;",
            "        while (ret_flow < f) {",
            "            if (use_beruman) {",
            "                if (!beruman(s, t)) break;",
            "                use_beruman = false;",
            "            } else {",
            "                if (!dijkstra(s, t)) break;",
            "            }",
            "",
            "            // update h,f,d",
            "            for (int v = 0; v < n; v++)",
            "                h[v] += dist[v];",
            "",
            "            Cap d = f - ret_flow;",
            "            for (int v = t; v != s; v = prevv[v]) {",
            "                d = min(d, G[prevv[v]][preve[v]].cap);",
            "            }",
            "",
            "            ret_flow += d;",
            "            ret_cost += d * h[t];",
            "            for (int v = t; v != s; v = prevv[v]) {",
            "                edge &e = G[prevv[v]][preve[v]];",
            "                e.cap -= d;",
            "                G[v][e.rev].cap += d;",
            "            }",
            "        }",
            "        return {ret_flow, ret_cost};",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./graph/beruman_ford.cpp": {
        "prefix": "snp beruman_ford",
        "body": [
            "",
            "// beruman_ford",
            "// \u8ca0\u8fba\u3092\u542b\u3080\u30b0\u30e9\u30d5\u3092\u53d7\u3051\u53d6\u308a, s\u304b\u3089\u306e\u6700\u77ed\u7d4c\u8def\u3092\u8a08\u7b97\u3059\u308b.",
            "template <typename T, const T INF>",
            "struct BerumanFord {",
            "    struct edge {",
            "        int a, b;",
            "        T c;",
            "        edge() {}",
            "        edge(int a, int b, T c) : a(a), b(b), c(c) {}",
            "    };",
            "",
            "  private:",
            "    int n;",
            "    vector<edge> edges;",
            "    vector<T> dist;",
            "    bool find_negative_from_s = false;",
            "    vector<int> negative_loop_from_s, prev;",
            "",
            "  public:",
            "    BerumanFord(int n) : n(n) {",
            "        dist.assign(n, INF);",
            "        negative_loop_from_s.assign(n, 0);",
            "        prev.assign(n, -1);",
            "    }",
            "",
            "    // add_edge",
            "    // a\u304b\u3089b\u3078\u8fba\u91cd\u307fc\u306e\u8fba\u3092\u306f\u308b",
            "    void add_edge(int a, int b, T c) {",
            "        edges.push_back(edge{a, b, c});",
            "    }",
            "",
            "    // solve",
            "    // s\u304b\u3089\u306e\u6700\u77ed\u7d4c\u8def\u3092\u6c42\u3081\u308b. \u3082\u3057s\u304b\u3089\u5230\u9054\u53ef\u80fd\u306a\u8ca0\u9589\u8def\u304c\u5b58\u5728\u3059\u308c\u3070",
            "    // find_negative = true\u3068\u306a\u308b. s\u304b\u3089\u306e\u6700\u77ed\u7d4c\u8def\u9577\u3092\u8fd4\u3059.",
            "    // \u8a08\u7b97\u91cf: O(|V||E|)",
            "    vector<T> solve(int s = 0) {",
            "        fill(dist.begin(), dist.end(), INF);",
            "        fill(negative_loop_from_s.begin(), negative_loop_from_s.end(), 0);",
            "        dist[s] = 0;",
            "",
            "        for (int i = 0; i < n; ++i) {",
            "            bool update = false;",
            "            for (const edge &e : edges) {",
            "                if (dist[e.a] != INF && dist[e.b] > dist[e.a] + e.c) {",
            "                    dist[e.b] = dist[e.a] + e.c;",
            "                    prev[e.b] = e.a;",
            "                    update    = true;",
            "                    if (i == n - 1) negative_loop_from_s[e.b] = 1;",
            "                }",
            "            }",
            "            if (!update) break;",
            "            if (i == n - 1) find_negative_from_s = true;",
            "        }",
            "        return dist;",
            "    }",
            "",
            "    // find_negloop_from_s",
            "    // s\u304b\u3089\u5230\u9054\u53ef\u80fd\u306a\u8ca0\u9589\u8def\u304c\u5b58\u5728\u3059\u308c\u3070true, \u305d\u3046\u3067\u306a\u3051\u308c\u3070false\u3092\u8fd4\u3059kaesu.",
            "    // \u5236\u7d04: solve()\u3092\u547c\u3093\u3067\u3044\u308b\u3053\u3068",
            "    bool find_negloop_from_s() {",
            "        return find_negative_from_s;",
            "    }",
            "",
            "    // negloop_from_s",
            "    // s\u304b\u3089v\u307e\u3067\u306e\u7d4c\u8def\u306b\u8ca0\u9589\u8def\u304c\u5b58\u5728\u3059\u308b\u306a\u3089a[v]=1,\u305d\u3046\u3067\u306a\u3044\u3068\u304dA[v]=0\u3067\u3042\u308b\u3088\u3046\u306a",
            "    // \u914d\u5217A\u3092\u8fd4\u3059.",
            "    // \u5236\u7d04: \u4ee5\u524d\u306bsolve()\u3092\u547c\u3093\u3067\u3044\u308b\u3053\u3068",
            "    // \u8a08\u7b97\u91cf: O(|V||E|) (dfs\u3068\u304b\u3067\u3082\u3063\u3068\u65e9\u304f\u3067\u304d\u308b\u3051\u3069\u3042\u3093\u307e\u610f\u5473\u306a\u3044\u306e\u3067ok)",
            "    vector<int> negloop_from_s() {",
            "        for (int i = 0; i < n; ++i) {",
            "            for (const edge &e : edges) {",
            "                if (negative_loop_from_s[e.a]) negative_loop_from_s[e.b] = 1;",
            "            }",
            "        }",
            "        return negative_loop_from_s;",
            "    }",
            "",
            "    // find_neg_loop",
            "    // (s\u304b\u3089\u306f\u5230\u9054\u3067\u304d\u306a\u3044\u3082\u306e\u3082\u542b\u3081\u3066)\u30b0\u30e9\u30d5\u306e\u8ca0\u9589\u8def\u304c\u3042\u308b\u304b\u3092\u691c\u51fa\u3059\u308b",
            "    // \u8a08\u7b97\u91cf: O(|V||E|)",
            "    bool find_neg_loop() {",
            "        bool neg_loop = false;",
            "        vector<T> dist(n, 0);",
            "        for (int i = 0; i < n; ++i) {",
            "            for (const edge &e : edges) {",
            "                if (dist[e.a] != INF && dist[e.b] > dist[e.a] + e.c) {",
            "                    dist[e.b] = dist[e.a] + e.c;",
            "                    if (i == n - 1) neg_loop = true;",
            "                }",
            "            }",
            "        }",
            "        return neg_loop;",
            "    }",
            "",
            "    // restore_path",
            "    // \u9802\u70b9s\u304b\u3089t\u307e\u3067\u306e\u6700\u77ed\u7d4c\u8def\u3092\u6c42\u3081\u308b\u3002",
            "    // \u6700\u77ed\u7d4c\u8def\u304c\u5b58\u5728\u3059\u308b\u5834\u5408, \u8fd4\u308a\u5024\u306f\u5148\u982d\u306bs,t\u3092\u542b\u3080. \u5b58\u5728\u3057\u306a\u3044\u3068\u304d\u7a7a\u3092\u8fd4\u3059.",
            "    // \u5236\u7d04: s\u306f\u4ee5\u524d\u306bsolve(s)\u304c\u547c\u3070\u308c\u3066\u3044\u308b. 0 <= t < n",
            "    vector<int> restore_path(int s, int t) {",
            "        if (dist[t] == INF) return {};",
            "",
            "        vector<int> ret;",
            "        int now_v = t;",
            "        ret.push_back(now_v);",
            "        while (now_v != s) {",
            "            now_v = prev[now_v];",
            "            ret.push_back(now_v);",
            "        }",
            "        reverse(ret.begin(), ret.end());",
            "        return ret;",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./graph/dinic.cpp": {
        "prefix": "snp dinic",
        "body": [
            "",
            "// Dinic",
            "// \u6700\u5927\u6d41\u3092\u6c42\u3081\u308b.",
            "template <typename T, const T INF>",
            "struct Dinic {",
            "    struct edge {",
            "        int to, rev;",
            "        T cap;",
            "        edge() {}",
            "        edge(int to, T cap, int rev) : to(to), rev(rev), cap(cap) {}",
            "    };",
            "",
            "    int n;",
            "    vector<vector<edge>> G;",
            "    vector<int> level, iter;",
            "",
            "    Dinic(int n) : n(n) {",
            "        G.resize(n);",
            "        level.resize(n);",
            "        iter.resize(n);",
            "    }",
            "",
            "    // add_edge",
            "    // a\u304b\u3089b\u3078\u5bb9\u91cfc\u306e\u8fba\u3092\u306f\u308b.",
            "    // \u5236\u7d04: 0 <= a,b < n,c >= 0",
            "    void add_edge(int a, int b, T c) {",
            "        G[a].push_back(edge{b, c, (int)G[b].size()});",
            "        G[b].push_back(edge{a, T(0), (int)G[a].size() - 1});",
            "    }",
            "",
            "    void bfs(int s) {",
            "        fill(level.begin(), level.end(), -1);",
            "        level[s] = 0;",
            "        queue<int> q;",
            "        q.push(s);",
            "        while (!q.empty()) {",
            "            int v = q.front();",
            "            q.pop();",
            "            for (const auto &e : G[v]) {",
            "                if (e.cap > 0 && level[e.to] < 0) {",
            "                    level[e.to] = level[v] + 1;",
            "                    q.push(e.to);",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    T dfs(int v, int t, T f) {",
            "        if (v == t) return f;",
            "        for (int &i = iter[v]; i < (int)G[v].size(); i++) {",
            "            edge &e = G[v][i];",
            "            if (e.cap > 0 && level[v] < level[e.to]) {",
            "                T d = dfs(e.to, t, min(f, e.cap));",
            "                if (d > 0) {",
            "                    e.cap -= d;",
            "                    G[e.to][e.rev].cap += d;",
            "                    return d;",
            "                }",
            "            }",
            "        }",
            "        return 0;",
            "    }",
            "",
            "    // solve",
            "    // s\u304b\u3089t\u3078\u306e\u6700\u5927\u6d41\u3092\u6c42\u3081\u308b.",
            "    // \u5236\u7d04: 0 <= s,t < n",
            "    // \u8a08\u7b97\u91cf: O(|V|^2|E|)",
            "    T solve(int s, int t) {",
            "        T flow = T(0);",
            "        for (;;) {",
            "            bfs(s);",
            "            if (level[t] < 0) return flow;",
            "            fill(iter.begin(), iter.end(), 0);",
            "            T f;",
            "            while ((f = dfs(s, t, INF)) > 0) {",
            "                flow += f;",
            "            }",
            "        }",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./graph/prim.cpp": {
        "prefix": "snp prim",
        "body": [
            "",
            "// Prim",
            "// Prim\u6cd5\u3067\u6700\u5c0f\u5168\u57df\u6728\u3092\u6c42\u3081\u308b.",
            "template <typename T, const T INF>",
            "struct Prim {",
            "    struct edge {",
            "        int to;",
            "        T cost;",
            "        int id;",
            "",
            "        edge(int to, T c, int id) : to(to), cost(c), id(id) {}",
            "    };",
            "    function<bool(const edge &, const edge &)> compare = [](const edge &a, const edge &b) {",
            "        return a.cost > b.cost;",
            "    };",
            "",
            "    int n;",
            "    int m = 0;",
            "    vector<int> used_id;",
            "    vector<vector<edge>> G;",
            "",
            "    Prim(int n) : n(n) {",
            "        G.resize(n);",
            "    }",
            "",
            "    // add_edge",
            "    // a\u3068b\u306e\u9593\u306b\u30b3\u30b9\u30c8c\u306e\u7121\u5411\u8fba\u3092\u306f\u308b",
            "    void add_edge(int a, int b, T c) {",
            "        G[a].emplace_back(b, c, m);",
            "        G[b].emplace_back(a, c, m++);",
            "    }",
            "",
            "    // solve",
            "    // \u6700\u5c0f\u5168\u57df\u6728\u3092\u6c42\u3081\u308b.",
            "    // \u8a08\u7b97\u91cf: O(|E|log|V|)",
            "    T solve() {",
            "        used_id.assign(m, 0);",
            "        T ans = T(0);",
            "        vector<int> visited(n, 0);",
            "        priority_queue<edge, vector<edge>, decltype(compare)> q{compare};",
            "        q.emplace(0, 0, -1);",
            "",
            "        while (!q.empty()) {",
            "            edge e = q.top();",
            "            q.pop();",
            "            if (visited[e.to]) continue;",
            "            if (e.id >= 0) used_id[e.id] = 1;",
            "            ans += e.cost;",
            "            visited[e.to] = 1;",
            "            for (const edge &e2 : G[e.to]) {",
            "                if (visited[e2.to]) continue;",
            "                q.push(e2);",
            "            }",
            "        }",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./graph/rerooting.cpp": {
        "prefix": "snp rerooting",
        "body": [
            "",
            "struct DP {",
            "    int dp;",
            "    DP(int dp = 1) : dp(dp) {}",
            "    DP operator+(const DP &a) const { // merge function",
            "        return DP(dp + a.dp);",
            "    }",
            "    DP addroot() const { // g = g(f(dp_0,dp_1,...,dp_N),v) : add root",
            "        return DP(dp + 1);",
            "    }",
            "};",
            "DP unit = DP(); // unit",
            "",
            "template <class T>",
            "struct Rerooting {",
            "    int N;",
            "    vector<int> parents;",
            "    vector<vector<int>> G;",
            "    vector<vector<T>> dp;",
            "    vector<T> ans;",
            "    Rerooting(int N, const vector<vector<int>> &G) : N(N), G(G) {",
            "        parents.assign(N, -1);",
            "        dp.resize(N);",
            "        ans.resize(N);",
            "        dfs(0);",
            "        bfs(0);",
            "    }",
            "    T dfs(int v, int p = -1) {",
            "        T ret = unit;",
            "        dp[v] = vector<T>(G[v].size());",
            "        for (int i = 0; i < (int)G[v].size(); ++i) {",
            "            if (p == G[v][i]) {",
            "                parents[v] = i;",
            "                continue;",
            "            }",
            "            dp[v][i] = dfs(G[v][i], v);",
            "            ret      = ret + dp[v][i];",
            "        }",
            "        return ret.addroot();",
            "    }",
            "    void bfs(int v, const T &res_p = unit, int p = -1) {",
            "        if (p != -1) dp[v][parents[v]] = res_p;",
            "        int deg = G[v].size();",
            "        vector<T> dpl(deg + 1), dpr(deg + 1);",
            "        dpl[0]   = unit;",
            "        dpr[deg] = unit;",
            "        for (int i = 0; i < deg; ++i)",
            "            dpl[i + 1] = dpl[i] + dp[v][i];",
            "        for (int i = deg - 1; i >= 0; --i)",
            "            dpr[i] = dpr[i + 1] + dp[v][i];",
            "        ans[v] = dpr[0].addroot();",
            "        for (int i = 0; i < deg; ++i) {",
            "            if (parents[v] == i) continue;",
            "            T d = dpl[i] + dpr[i + 1];",
            "            bfs(G[v][i], d.addroot(), v);",
            "        }",
            "    }",
            "    T operator[](int k) {",
            "        return ans[k];",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./graph/bfs01.cpp": {
        "prefix": "snp bfs01",
        "body": [
            "",
            "// https://atcoder.jp/contests/arc005/submissions/34363432",
            "",
            "// Bfs01",
            "// n\u306f\u9802\u70b9\u6570, G\u306f\u96a3\u63a5\u30ea\u30b9\u30c8\u3067\u96a3\u63a5\u9802\u70b9\u3068\u305d\u306e\u9802\u70b9\u3068\u306e\u8ddd\u96e2(0 or 1)\u3092\u3082\u3064",
            "struct Bfs01 {",
            "    int n;",
            "    vector<vector<pair<int, int>>> G;",
            "    vector<int> dist;",
            "",
            "    Bfs01(int n, vector<vector<pair<int, int>>> &G) : n(n), G(G) {",
            "        dist.assign(n, -1);",
            "    }",
            "",
            "    // shortest_path",
            "    // \u9802\u70b9s\u304b\u3089\u306e\u6700\u77ed\u7d4c\u8def\u3092\u6c42\u3081\u308b.",
            "    // \u5236\u7d04: 0 <= s < n",
            "    void shortest_path(int s) {",
            "        fill(dist.begin(), dist.end(), -1);",
            "        dist[s] = 0;",
            "",
            "        deque<int> q;",
            "        q.push_back(s);",
            "        while (!q.empty()) {",
            "            int v = q.front();",
            "            q.pop_front();",
            "            for (auto &p : G[v]) {",
            "                auto [u, c] = p;",
            "                if (dist[u] >= 0) continue;",
            "                dist[u] = dist[v] + c;",
            "                if (c == 0)",
            "                    q.push_front(u);",
            "                else",
            "                    q.push_back(u);",
            "            }",
            "        }",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./graph/kruscal.cpp": {
        "prefix": "snp kruscal",
        "body": [
            "",
            "",
            "// UnionFind",
            "// \u30b0\u30eb\u30fc\u30d7\u3092\u7ba1\u7406\u3059\u308b\u30c7\u30fc\u30bf\u69cb\u9020",
            "struct UnionFind {",
            "    int n;",
            "    vector<int> parents;",
            "",
            "    UnionFind(int n) : n(n) {",
            "        parents.assign(n, -1);",
            "    }",
            "",
            "    // find",
            "    // x\u306e\u89aa\u3092\u8fd4\u3059.",
            "    // \u5236\u7d04: 0 <= x < n",
            "    int find(int x) {",
            "        if (parents[x] < 0) return x;",
            "        return parents[x] = find(parents[x]);",
            "    }",
            "",
            "    // unite",
            "    // x\u3068y\u3092\u542b\u3080\u30b0\u30eb\u30fc\u30d7\u3092\u4f75\u5408",
            "    // \u5236\u7d04: 0 <= x,y < n",
            "    void unite(int x, int y) { // x\u3068y\u306e\u542b\u3080\u30b0\u30eb\u30fc\u30d7\u3092\u4f75\u5408",
            "        int px = find(x);",
            "        int py = find(y);",
            "        if (parents[px] > parents[py]) swap(px, py);",
            "        if (px != py) {",
            "            parents[px] += parents[py];",
            "            parents[py] = px;",
            "        }",
            "    }",
            "",
            "    // same",
            "    // x\u3068y\u304c\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306b\u3044\u308b\u304b\u5224\u5b9a",
            "    // \u5236\u7d04: 0 <= x,y < n",
            "    bool same(int x, int y) {",
            "        return find(x) == find(y);",
            "    }",
            "",
            "    // size",
            "    // x\u3068\u540c\u3058\u30b0\u30eb\u30fc\u30d7\u306e\u30e1\u30f3\u30d0\u30fc\u306e\u500b\u6570",
            "    // \u5236\u7d04: 0 <= x < n",
            "    int size(int x) {",
            "        return -parents[find(x)];",
            "    }",
            "",
            "    // root",
            "    // \u6839\u3092\u5168\u3066\u5217\u6319\u3059\u308b",
            "    vector<int> root() {",
            "        vector<int> res;",
            "        for (int i = 0; i < n; i++) {",
            "            if (parents[i] < 0) res.push_back(i);",
            "        }",
            "        return res;",
            "    }",
            "",
            "    // group_count",
            "    // \u30b0\u30eb\u30fc\u30d7\u306e\u6570\u3092\u8fd4\u3059.",
            "    int group_count() { // uf\u306e\u30b0\u30eb\u30fc\u30d7\u306e\u6570\u3092\u6570\u3048\u308b",
            "        return (int)root().size();",
            "    }",
            "};",
            "",
            "// Kruscal",
            "// Kruscal\u6cd5\u3067\u6700\u5c0f\u5168\u57df\u68ee\u3092\u6c42\u3081\u308b.",
            "template <typename T, const T INF>",
            "struct Kruscal {",
            "    struct edge {",
            "        int a, b;",
            "        T cost;",
            "        int id;",
            "        edge(int a, int b, T c, int id) : a(a), b(b), cost(c), id(id) {}",
            "    };",
            "",
            "    int n;",
            "    int m = 0;",
            "    vector<edge> edges;",
            "    vector<int> used_id;",
            "",
            "    Kruscal(int n) : n(n) {}",
            "",
            "    // add_edge",
            "    // a\u304b\u3089b\u3078\u30b3\u30b9\u30c8c\u306e\u8fba\u3092\u5f35\u308b",
            "    void add_edge(int a, int b, T c) {",
            "        edges.emplace_back(a, b, c, m++);",
            "    }",
            "",
            "    // solve",
            "    // \u6700\u5c0f\u5168\u57df\u68ee\u3092\u6c42\u3081\u3066, \u305d\u306e\u30b3\u30b9\u30c8\u3092\u8fd4\u3059.",
            "    // \u8a08\u7b97\u91cf: O(|E|log|E|)",
            "    T solve() {",
            "        used_id.assign(m, 0);",
            "        sort(edges.begin(), edges.end(),",
            "             [](const edge &a, const edge &b) { return a.cost < b.cost; });",
            "",
            "        T ans = T(0);",
            "        UnionFind uf(n);",
            "        for (const edge &e : edges) {",
            "            if (uf.same(e.a, e.b)) continue;",
            "            ans += e.cost;",
            "            used_id[e.id] = 1;",
            "            uf.unite(e.a, e.b);",
            "        }",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./graph/strongly_connected_components.cpp": {
        "prefix": "snp strongly_connected_components",
        "body": [
            "",
            "struct StronglyConnectedComponents {",
            "  private:",
            "    std::vector<int> visited;",
            "    std::vector<int> memo;",
            "",
            "    void _dfs(int v) {",
            "        group[v] = -1;",
            "        for (const int &u : G[v]) {",
            "            if (group[u] > 0) _dfs(u);",
            "        }",
            "        order.push_back(v);",
            "    }",
            "",
            "    void rdfs(int v, int cnt) {",
            "        group[v] = cnt;",
            "        scc_group[cnt].push_back(v);",
            "        for (const int &u : rG[v]) {",
            "            if (group[u] < 0) rdfs(u, cnt);",
            "        }",
            "    }",
            "",
            "    int _dp(int v) {",
            "        if (visited[v] >= 0) return memo[v];",
            "        int ret = 0;",
            "        for (const int &u : sccG[v]) {",
            "            ret |= _dp(u);",
            "        }",
            "        visited[v]     = 1;",
            "        return memo[v] = ret;",
            "    }",
            "",
            "  public:",
            "    int N, N_scc;",
            "    std::vector<std::vector<int>> G, rG;",
            "    std::vector<int> group, order;",
            "    std::vector<std::vector<int>> scc_group, sccG;",
            "",
            "    // StronglyConnectedComponents receives N as the number of vertex of graph G.",
            "    StronglyConnectedComponents(int N) : N(N) {",
            "        G.resize(N);",
            "        rG.resize(N);",
            "        group.assign(N, 1);",
            "    }",
            "",
            "    // add_edge receives a,b and creates edge a -> b.",
            "    // contraint: 0 <= a,b < N",
            "    void add_edge(int a, int b) {",
            "        G[a].push_back(b);",
            "        rG[b].push_back(a);",
            "    }",
            "",
            "    // build bulids strongly connected components.",
            "    // when build_scc is true, build scc_G",
            "    void build(bool build_scc) {",
            "        for (int i = 0; i < N; i++) {",
            "            if (group[i] > 0) _dfs(i);",
            "        }",
            "        std::reverse(order.begin(), order.end());",
            "        N_scc = 0;",
            "        for (const int &v : order) {",
            "            if (group[v] < 0) {",
            "                scc_group.push_back({});",
            "                rdfs(v, N_scc);",
            "                N_scc++;",
            "            }",
            "        }",
            "",
            "        if (!build_scc)",
            "            return;",
            "",
            "        sccG.resize(N_scc);",
            "        for (int i = 0; i < N_scc; i++) {",
            "            std::set<int> st;",
            "            for (const int &v : scc_group[i]) {",
            "                for (const int &u : G[v]) {",
            "                    st.insert(group[u]);",
            "                }",
            "            }",
            "            for (auto itr = st.begin(); itr != st.end(); itr++) {",
            "                sccG[i].push_back(*itr);",
            "            }",
            "        }",
            "    }",
            "",
            "    // DP MUST BE IMPLEMENTED DEPENDING ON THE PROBLEM TO BE SOLVED.",
            "    // build must be called before dp is called.",
            "    int dp() {",
            "        visited.assign(N_scc, -1);",
            "        memo.resize(N_scc, 0);",
            "        for (int i = 0; i < N_scc; i++) {",
            "            if ((int)scc_group[i].size() > 1) {",
            "                memo[i]    = 1;",
            "                visited[i] = 1;",
            "            }",
            "        }",
            "",
            "        int ans = 0;",
            "        for (int i = 0; i < N_scc; i++) {",
            "            if (_dp(i)) ans += (int)scc_group[i].size();",
            "        }",
            "        return ans;",
            "    }",
            "",
            "    // scc[i] returns a group which vertex i belongs to.",
            "    // this function is valid after build () is called.",
            "    int operator[](int i) {",
            "        return group[i];",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./graph/primal_dual2.cpp": {
        "prefix": "snp primal_dual2",
        "body": [
            "",
            "// PrimalDual2",
            "// berumanford\u6cd5\u3092\u7528\u3044\u3066\u6700\u5c0f\u8cbb\u7528\u6d41\u3092\u6c42\u3081\u308b.",
            "// \u6700\u521d\u306e\u30b0\u30e9\u30d5\u306b\u306f\u8ca0\u9589\u8def\u304c\u542b\u307e\u308c\u3066\u306f\u3044\u3051\u306a\u3044.",
            "template <typename Cap, typename Cost, const Cost INF>",
            "struct PrimalDual2 {",
            "    struct edge {",
            "        int to;",
            "        Cap cap;",
            "        Cost cost;",
            "        int rev;",
            "    };",
            "",
            "    int n;",
            "    vector<vector<edge>> G;",
            "    vector<Cost> dist;",
            "    vector<int> prevv, preve;",
            "",
            "    PrimalDual2(int n) : n(n) {",
            "        G.resize(n);",
            "        dist.resize(n);",
            "        prevv.resize(n);",
            "        preve.resize(n);",
            "    }",
            "",
            "    // add_edge",
            "    // from\u304b\u3089to\u3078\u5bb9\u91cfcap, \u30b3\u30b9\u30c8cost\u306e\u8fba\u3092\u5f35\u308b.",
            "    // \u5236\u7d04: 0 <= from,to < n,cap >= 0,",
            "    void add_edge(int from, int to, Cap cap, Cost cost) {",
            "        G[from].push_back((edge){to, cap, cost, (int)G[to].size()});",
            "        G[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});",
            "    }",
            "",
            "    // beruman",
            "    int beruman(int s, int t) {",
            "        fill(dist.begin(), dist.end(), INF);",
            "        dist[s]     = 0;",
            "        bool update = true;",
            "        while (update) {",
            "            update = false;",
            "            for (int v = 0; v < n; v++) {",
            "                if (dist[v] == INF) continue;",
            "                for (int i = 0; i < (int)G[v].size(); i++) {",
            "                    edge &e = G[v][i];",
            "                    if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {",
            "                        dist[e.to]  = dist[v] + e.cost;",
            "                        prevv[e.to] = v;",
            "                        preve[e.to] = i;",
            "                        update      = true;",
            "                    }",
            "                }",
            "            }",
            "        }",
            "        return dist[t] < INF;",
            "    }",
            "",
            "    // solve",
            "    // s\u304b\u3089t\u3078f\u3060\u3051\u6d41\u3059\u305f\u3081\u306e\u6700\u5c0f\u8cbb\u7528\u3092\u6c42\u3081\u308b.",
            "    // \u5236\u7d04: 0 <= s,t < n,f >= 0",
            "    // \u8a08\u7b97\u91cf: O(f|V||E|)",
            "    pair<Cap, Cost> solve(int s, int t, Cap f) {",
            "        Cost ret_cost = 0;",
            "        Cap ret_flow  = 0;",
            "        while (ret_flow < f) {",
            "            if (!beruman(s, t))",
            "                break;",
            "            Cap d = f - ret_flow;",
            "            for (int v = t; v != s; v = prevv[v]) {",
            "                d = min(d, G[prevv[v]][preve[v]].cap);",
            "            }",
            "            ret_flow += d;",
            "            ret_cost += d * dist[t];",
            "            for (int v = t; v != s; v = prevv[v]) {",
            "                edge &e = G[prevv[v]][preve[v]];",
            "                e.cap -= d;",
            "                G[v][e.rev].cap += d;",
            "            }",
            "        }",
            "        return {ret_flow, ret_cost};",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./graph/topological_sort.cpp": {
        "prefix": "snp topological_sort",
        "body": [
            "",
            "// topological_sort",
            "// \u6709\u5411\u30b0\u30e9\u30d5G\u306e\u96a3\u63a5\u30ea\u30b9\u30c8\u3092\u53d7\u3051\u53d6\u3063\u3066DAG\u3067\u3042\u308c\u3070\u30c8\u30dd\u30ed\u30b8\u30ab\u30eb\u30bd\u30fc\u30c8\u3057\u305f\u7d50\u679c\u3092\u8fd4\u3057,",
            "// \u305d\u3046\u3067\u306a\u3051\u308c\u3070{-1}\u3092\u8fd4\u3059.",
            "vector<int> topological_sort(const vector<vector<int>> &G) {",
            "    int n = (int)G.size();",
            "    vector<int> ans;",
            "    stack<int> stk;",
            "    vector<int> indeg(n, 0);",
            "    for (int i = 0; i < n; i++) {",
            "        for (const int &v : G[i])",
            "            indeg[v]++;",
            "    }",
            "    for (int i = 0; i < n; i++) {",
            "        if (indeg[i] == 0) {",
            "            stk.push(i);",
            "            indeg[i] = -1;",
            "        }",
            "    }",
            "    while (!stk.empty()) {",
            "        int v = stk.top();",
            "        ans.push_back(v);",
            "        stk.pop();",
            "        for (const int &u : G[v]) {",
            "            if (--indeg[u] == 0) {",
            "                stk.push(u);",
            "                indeg[u] = -1;",
            "            }",
            "        }",
            "    }",
            "    if (all_of(indeg.begin(), indeg.end(), [](int x) { return x < 0; }))",
            "        return ans;",
            "    else",
            "        return {-1};",
            "}"
        ],
        "description": ""
    },
    "./graph/dijkstra.cpp": {
        "prefix": "snp dijkstra",
        "body": [
            "",
            "// Dijkstra",
            "// dijkstra\u6cd5\u3067\u6700\u77ed\u7d4c\u8def\u3092\u6c42\u3081\u308b.",
            "template <typename T, const T INF>",
            "struct Dijkstra {",
            "    using edge = pair<T, int>;",
            "    int n;",
            "",
            "    vector<vector<edge>> G;",
            "    vector<T> dist;",
            "    vector<int> prev;",
            "    Dijkstra(int n) : n(n) {",
            "        G.resize(n);",
            "        dist.resize(n);",
            "        prev.resize(n);",
            "    }",
            "",
            "    // add_edge",
            "    // a\u304b\u3089b\u3078\u30b3\u30b9\u30c8c\u306e\u8fba\u3092\u5f35\u308b",
            "    // \u5236\u7d04: c >= 0",
            "    void add_edge(int a, int b, T c) {",
            "        G[a].emplace_back(c, b);",
            "    }",
            "",
            "    // solve",
            "    // s\u304b\u3089\u306e\u6700\u77ed\u7d4c\u8def\u3092\u6c42\u3081\u308b.",
            "    // \u8a08\u7b97\u91cf: O(|E|log|V|)",
            "    vector<T> solve(int s = 0) {",
            "        fill(dist.begin(), dist.end(), INF);",
            "        fill(prev.begin(), prev.end(), -1);",
            "        dist[s] = 0;",
            "",
            "        priority_queue<edge, vector<edge>, greater<edge>> q;",
            "        q.push({0, s});",
            "",
            "        while (!q.empty()) {",
            "            edge p = q.top();",
            "            q.pop();",
            "            auto [d, v] = p;",
            "            if (dist[v] < d) continue;",
            "            for (const auto &p : G[v]) {",
            "                auto [cost, u] = p;",
            "                if (dist[u] > dist[v] + cost) {",
            "                    dist[u] = dist[v] + cost;",
            "                    prev[u] = v;",
            "                    q.push({dist[u], u});",
            "                }",
            "            }",
            "        }",
            "        return dist;",
            "    }",
            "",
            "    // restore_path",
            "    // \u9802\u70b9s\u304b\u3089t\u307e\u3067\u306e\u6700\u77ed\u7d4c\u8def\u3092\u6c42\u3081\u308b\u3002",
            "    // \u6700\u77ed\u7d4c\u8def\u304c\u5b58\u5728\u3059\u308b\u5834\u5408, \u8fd4\u308a\u5024\u306f\u5148\u982d\u306bs,t\u3092\u542b\u3080. \u5b58\u5728\u3057\u306a\u3044\u3068\u304d\u7a7a\u3092\u8fd4\u3059.",
            "    // \u5236\u7d04: s\u306f\u4ee5\u524d\u306bsolve(s)\u304c\u547c\u3070\u308c\u3066\u3044\u308b. 0 <= t < n",
            "    vector<int> restore_path(int s, int t) {",
            "        if (dist[t] == INF) return {};",
            "",
            "        vector<int> ret;",
            "        int now_v = t;",
            "        ret.push_back(now_v);",
            "        while (now_v != s) {",
            "            now_v = prev[now_v];",
            "            ret.push_back(now_v);",
            "        }",
            "        reverse(ret.begin(), ret.end());",
            "        return ret;",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./graph/bfs.cpp": {
        "prefix": "snp bfs",
        "body": [
            "",
            "// Bfs",
            "// n\u306f\u9802\u70b9\u6570, G\u306f\u30b0\u30e9\u30d5\u3092\u96a3\u63a5\u30ea\u30b9\u30c8\u5f62\u5f0f\u3067\u6301\u3063\u305f\u3082\u306e",
            "template <typename T>",
            "struct Bfs {",
            "    int n;",
            "    vector<vector<int>> G;",
            "    vector<int> dist, prev_v;",
            "",
            "    Bfs(int n, vector<vector<int>> G) : n(n), G(G) {",
            "        dist.assign(n, -1);",
            "        prev_v.assign(n, -1);",
            "    }",
            "",
            "    // shortest_path",
            "    // \u9802\u70b9s\u304b\u3089\u4ed6\u306e\u4efb\u610f\u306e\u9802\u70b9\u307e\u3067\u306e\u6700\u77ed\u8ddd\u96e2\u3092\u6c42\u3081\u308b.",
            "    // \u5236\u7d04: 0 <= s < n",
            "    void shortest_path(int s) {",
            "        fill(dist.begin(), dist.end(), -1);",
            "        dist[s] = 0;",
            "        queue<int> q;",
            "        q.push(s);",
            "        while (!q.empty()) {",
            "            int v = q.front();",
            "            q.pop();",
            "            for (auto &u : G[v]) {",
            "                if (dist[u] >= 0) continue;",
            "                dist[u]   = dist[v] + 1;",
            "                prev_v[u] = v;",
            "                q.push(u);",
            "            }",
            "        }",
            "    }",
            "",
            "    // restore_path",
            "    // \u9802\u70b9s\u304b\u3089t\u307e\u3067\u306e\u6700\u77ed\u7d4c\u8def\u3092\u6c42\u3081\u308b\u3002",
            "    // \u6700\u77ed\u7d4c\u8def\u304c\u5b58\u5728\u3059\u308b\u5834\u5408, \u8fd4\u308a\u5024\u306f\u5148\u982d\u306bs,t\u3092\u542b\u3080. \u5b58\u5728\u3057\u306a\u3044\u3068\u304d\u7a7a\u3092\u8fd4\u3059.",
            "    // \u5236\u7d04: s\u306f\u4ee5\u524d\u306bshortest_path(s)\u304c\u547c\u3070\u308c\u3066\u3044\u308b. 0 <= t < n",
            "    // \u672aVerify",
            "    vector<int> restore_path(int s, int t) {",
            "        if (dist[s] != 0) {",
            "            cerr << \"error when restore_path() is called.\";",
            "            exit(1);",
            "        }",
            "        if (dist[t] < 0) return {};",
            "",
            "        vector<int> ret;",
            "        int now_v = t;",
            "        ret.push_back(now_v);",
            "        while (now_v != s) {",
            "            now_v = prev_v[now_v];",
            "            ret.push_back(now_v);",
            "        }",
            "        reverse(ret.begin(), ret.end());",
            "        return ret;",
            "    }",
            "};"
        ],
        "description": ""
    },
    "./graph/lowest_common_ancestor.cpp": {
        "prefix": "snp lowest_common_ancestor",
        "body": [
            "",
            "struct LowestCommonAncestor {",
            "    int N, root, K;",
            "    vector<int> dist;",
            "    vector<vector<int>> G, parents;",
            "",
            "    void dfs() {",
            "        dist[root] = 0;",
            "        stack<int> st;",
            "        st.push(root);",
            "        while (!st.empty()) {",
            "            int v = st.top();",
            "            st.pop();",
            "            for (int e : G[v]) {",
            "                if (dist[e] >= 0) {",
            "                    parents[v][0] = e;",
            "                    continue;",
            "                }",
            "                dist[e] = dist[v] + 1;",
            "                st.push(e);",
            "            }",
            "        }",
            "    }",
            "",
            "    LowestCommonAncestor(int N, const vector<vector<int>> &G, int root = 0)",
            "        : N(N), G(G), root(root) {",
            "        K = 1;",
            "        while ((1 << K) < N)",
            "            ++K;",
            "        dist.assign(N, -1);",
            "        dist[root] = 0;",
            "        parents.assign(N, vector<int>(K, -1));",
            "",
            "        dfs();",
            "        for (int i = 0; i < K - 1; ++i) {",
            "            for (int j = 0; j < N; ++j) {",
            "                if (parents[j][i] < 0) continue;",
            "                parents[j][i + 1] = parents[parents[j][i]][i];",
            "            }",
            "        }",
            "    }",
            "",
            "    int query(int u, int v) {",
            "        if (dist[u] < dist[v]) swap(u, v);",
            "        for (int k = 0; k < K; ++k) {",
            "            if (((dist[u] - dist[v]) >> k) & 1) u = parents[u][k];",
            "        }",
            "        if (u == v) return u;",
            "        for (int k = K - 1; k >= 0; --k) {",
            "            if (parents[u][k] != parents[v][k]) {",
            "                u = parents[u][k];",
            "                v = parents[v][k];",
            "            }",
            "        }",
            "        return parents[u][0];",
            "    }",
            "",
            "    int operator[](int k) {",
            "        return dist[k];",
            "    }",
            "};"
        ],
        "description": ""
    },
}